"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/js-yaml";
exports.ids = ["vendor-chunks/js-yaml"];
exports.modules = {

/***/ "(rsc)/./node_modules/js-yaml/dist/js-yaml.mjs":
/*!***********************************************!*\
  !*** ./node_modules/js-yaml/dist/js-yaml.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CORE_SCHEMA: () => (/* binding */ CORE_SCHEMA),\n/* harmony export */   DEFAULT_SCHEMA: () => (/* binding */ DEFAULT_SCHEMA),\n/* harmony export */   FAILSAFE_SCHEMA: () => (/* binding */ FAILSAFE_SCHEMA),\n/* harmony export */   JSON_SCHEMA: () => (/* binding */ JSON_SCHEMA),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   YAMLException: () => (/* binding */ YAMLException),\n/* harmony export */   \"default\": () => (/* binding */ jsYaml),\n/* harmony export */   dump: () => (/* binding */ dump),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   loadAll: () => (/* binding */ loadAll),\n/* harmony export */   safeDump: () => (/* binding */ safeDump),\n/* harmony export */   safeLoad: () => (/* binding */ safeLoad),\n/* harmony export */   safeLoadAll: () => (/* binding */ safeLoadAll),\n/* harmony export */   types: () => (/* binding */ types)\n/* harmony export */ });\n/*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT */ function isNothing(subject) {\n    return typeof subject === \"undefined\" || subject === null;\n}\nfunction isObject(subject) {\n    return typeof subject === \"object\" && subject !== null;\n}\nfunction toArray(sequence) {\n    if (Array.isArray(sequence)) return sequence;\n    else if (isNothing(sequence)) return [];\n    return [\n        sequence\n    ];\n}\nfunction extend(target, source) {\n    var index, length, key, sourceKeys;\n    if (source) {\n        sourceKeys = Object.keys(source);\n        for(index = 0, length = sourceKeys.length; index < length; index += 1){\n            key = sourceKeys[index];\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction repeat(string, count) {\n    var result = \"\", cycle;\n    for(cycle = 0; cycle < count; cycle += 1){\n        result += string;\n    }\n    return result;\n}\nfunction isNegativeZero(number) {\n    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n}\nvar isNothing_1 = isNothing;\nvar isObject_1 = isObject;\nvar toArray_1 = toArray;\nvar repeat_1 = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1 = extend;\nvar common = {\n    isNothing: isNothing_1,\n    isObject: isObject_1,\n    toArray: toArray_1,\n    repeat: repeat_1,\n    isNegativeZero: isNegativeZero_1,\n    extend: extend_1\n};\n// YAML error class. http://stackoverflow.com/questions/8458984\nfunction formatError(exception, compact) {\n    var where = \"\", message = exception.reason || \"(unknown reason)\";\n    if (!exception.mark) return message;\n    if (exception.mark.name) {\n        where += 'in \"' + exception.mark.name + '\" ';\n    }\n    where += \"(\" + (exception.mark.line + 1) + \":\" + (exception.mark.column + 1) + \")\";\n    if (!compact && exception.mark.snippet) {\n        where += \"\\n\\n\" + exception.mark.snippet;\n    }\n    return message + \" \" + where;\n}\nfunction YAMLException$1(reason, mark) {\n    // Super constructor\n    Error.call(this);\n    this.name = \"YAMLException\";\n    this.reason = reason;\n    this.mark = mark;\n    this.message = formatError(this, false);\n    // Include stack trace in error object\n    if (Error.captureStackTrace) {\n        // Chrome and NodeJS\n        Error.captureStackTrace(this, this.constructor);\n    } else {\n        // FF, IE 10+ and Safari 6+. Fallback for others\n        this.stack = new Error().stack || \"\";\n    }\n}\n// Inherit from Error\nYAMLException$1.prototype = Object.create(Error.prototype);\nYAMLException$1.prototype.constructor = YAMLException$1;\nYAMLException$1.prototype.toString = function toString(compact) {\n    return this.name + \": \" + formatError(this, compact);\n};\nvar exception = YAMLException$1;\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n    var head = \"\";\n    var tail = \"\";\n    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n    if (position - lineStart > maxHalfLength) {\n        head = \" ... \";\n        lineStart = position - maxHalfLength + head.length;\n    }\n    if (lineEnd - position > maxHalfLength) {\n        tail = \" ...\";\n        lineEnd = position + maxHalfLength - tail.length;\n    }\n    return {\n        str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, \"â†’\") + tail,\n        pos: position - lineStart + head.length // relative position\n    };\n}\nfunction padStart(string, max) {\n    return common.repeat(\" \", max - string.length) + string;\n}\nfunction makeSnippet(mark, options) {\n    options = Object.create(options || null);\n    if (!mark.buffer) return null;\n    if (!options.maxLength) options.maxLength = 79;\n    if (typeof options.indent !== \"number\") options.indent = 1;\n    if (typeof options.linesBefore !== \"number\") options.linesBefore = 3;\n    if (typeof options.linesAfter !== \"number\") options.linesAfter = 2;\n    var re = /\\r?\\n|\\r|\\0/g;\n    var lineStarts = [\n        0\n    ];\n    var lineEnds = [];\n    var match;\n    var foundLineNo = -1;\n    while(match = re.exec(mark.buffer)){\n        lineEnds.push(match.index);\n        lineStarts.push(match.index + match[0].length);\n        if (mark.position <= match.index && foundLineNo < 0) {\n            foundLineNo = lineStarts.length - 2;\n        }\n    }\n    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n    var result = \"\", i, line;\n    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n    for(i = 1; i <= options.linesBefore; i++){\n        if (foundLineNo - i < 0) break;\n        line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);\n        result = common.repeat(\" \", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + \" | \" + line.str + \"\\n\" + result;\n    }\n    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n    result += common.repeat(\" \", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + \" | \" + line.str + \"\\n\";\n    result += common.repeat(\"-\", options.indent + lineNoLength + 3 + line.pos) + \"^\" + \"\\n\";\n    for(i = 1; i <= options.linesAfter; i++){\n        if (foundLineNo + i >= lineEnds.length) break;\n        line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);\n        result += common.repeat(\" \", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + \" | \" + line.str + \"\\n\";\n    }\n    return result.replace(/\\n$/, \"\");\n}\nvar snippet = makeSnippet;\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n    \"kind\",\n    \"multi\",\n    \"resolve\",\n    \"construct\",\n    \"instanceOf\",\n    \"predicate\",\n    \"represent\",\n    \"representName\",\n    \"defaultStyle\",\n    \"styleAliases\"\n];\nvar YAML_NODE_KINDS = [\n    \"scalar\",\n    \"sequence\",\n    \"mapping\"\n];\nfunction compileStyleAliases(map) {\n    var result = {};\n    if (map !== null) {\n        Object.keys(map).forEach(function(style) {\n            map[style].forEach(function(alias) {\n                result[String(alias)] = style;\n            });\n        });\n    }\n    return result;\n}\nfunction Type$1(tag, options) {\n    options = options || {};\n    Object.keys(options).forEach(function(name) {\n        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n            throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n        }\n    });\n    // TODO: Add tag format check.\n    this.options = options; // keep original options in case user wants to extend this type later\n    this.tag = tag;\n    this.kind = options[\"kind\"] || null;\n    this.resolve = options[\"resolve\"] || function() {\n        return true;\n    };\n    this.construct = options[\"construct\"] || function(data) {\n        return data;\n    };\n    this.instanceOf = options[\"instanceOf\"] || null;\n    this.predicate = options[\"predicate\"] || null;\n    this.represent = options[\"represent\"] || null;\n    this.representName = options[\"representName\"] || null;\n    this.defaultStyle = options[\"defaultStyle\"] || null;\n    this.multi = options[\"multi\"] || false;\n    this.styleAliases = compileStyleAliases(options[\"styleAliases\"] || null);\n    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n        throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n    }\n}\nvar type = Type$1;\n/*eslint-disable max-len*/ function compileList(schema, name) {\n    var result = [];\n    schema[name].forEach(function(currentType) {\n        var newIndex = result.length;\n        result.forEach(function(previousType, previousIndex) {\n            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {\n                newIndex = previousIndex;\n            }\n        });\n        result[newIndex] = currentType;\n    });\n    return result;\n}\nfunction compileMap() {\n    var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n            scalar: [],\n            sequence: [],\n            mapping: [],\n            fallback: []\n        }\n    }, index, length;\n    function collectType(type) {\n        if (type.multi) {\n            result.multi[type.kind].push(type);\n            result.multi[\"fallback\"].push(type);\n        } else {\n            result[type.kind][type.tag] = result[\"fallback\"][type.tag] = type;\n        }\n    }\n    for(index = 0, length = arguments.length; index < length; index += 1){\n        arguments[index].forEach(collectType);\n    }\n    return result;\n}\nfunction Schema$1(definition) {\n    return this.extend(definition);\n}\nSchema$1.prototype.extend = function extend(definition) {\n    var implicit = [];\n    var explicit = [];\n    if (definition instanceof type) {\n        // Schema.extend(type)\n        explicit.push(definition);\n    } else if (Array.isArray(definition)) {\n        // Schema.extend([ type1, type2, ... ])\n        explicit = explicit.concat(definition);\n    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n        // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n        if (definition.implicit) implicit = implicit.concat(definition.implicit);\n        if (definition.explicit) explicit = explicit.concat(definition.explicit);\n    } else {\n        throw new exception(\"Schema.extend argument should be a Type, [ Type ], \" + \"or a schema definition ({ implicit: [...], explicit: [...] })\");\n    }\n    implicit.forEach(function(type$1) {\n        if (!(type$1 instanceof type)) {\n            throw new exception(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");\n        }\n        if (type$1.loadKind && type$1.loadKind !== \"scalar\") {\n            throw new exception(\"There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.\");\n        }\n        if (type$1.multi) {\n            throw new exception(\"There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.\");\n        }\n    });\n    explicit.forEach(function(type$1) {\n        if (!(type$1 instanceof type)) {\n            throw new exception(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");\n        }\n    });\n    var result = Object.create(Schema$1.prototype);\n    result.implicit = (this.implicit || []).concat(implicit);\n    result.explicit = (this.explicit || []).concat(explicit);\n    result.compiledImplicit = compileList(result, \"implicit\");\n    result.compiledExplicit = compileList(result, \"explicit\");\n    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);\n    return result;\n};\nvar schema = Schema$1;\nvar str = new type(\"tag:yaml.org,2002:str\", {\n    kind: \"scalar\",\n    construct: function(data) {\n        return data !== null ? data : \"\";\n    }\n});\nvar seq = new type(\"tag:yaml.org,2002:seq\", {\n    kind: \"sequence\",\n    construct: function(data) {\n        return data !== null ? data : [];\n    }\n});\nvar map = new type(\"tag:yaml.org,2002:map\", {\n    kind: \"mapping\",\n    construct: function(data) {\n        return data !== null ? data : {};\n    }\n});\nvar failsafe = new schema({\n    explicit: [\n        str,\n        seq,\n        map\n    ]\n});\nfunction resolveYamlNull(data) {\n    if (data === null) return true;\n    var max = data.length;\n    return max === 1 && data === \"~\" || max === 4 && (data === \"null\" || data === \"Null\" || data === \"NULL\");\n}\nfunction constructYamlNull() {\n    return null;\n}\nfunction isNull(object) {\n    return object === null;\n}\nvar _null = new type(\"tag:yaml.org,2002:null\", {\n    kind: \"scalar\",\n    resolve: resolveYamlNull,\n    construct: constructYamlNull,\n    predicate: isNull,\n    represent: {\n        canonical: function() {\n            return \"~\";\n        },\n        lowercase: function() {\n            return \"null\";\n        },\n        uppercase: function() {\n            return \"NULL\";\n        },\n        camelcase: function() {\n            return \"Null\";\n        },\n        empty: function() {\n            return \"\";\n        }\n    },\n    defaultStyle: \"lowercase\"\n});\nfunction resolveYamlBoolean(data) {\n    if (data === null) return false;\n    var max = data.length;\n    return max === 4 && (data === \"true\" || data === \"True\" || data === \"TRUE\") || max === 5 && (data === \"false\" || data === \"False\" || data === \"FALSE\");\n}\nfunction constructYamlBoolean(data) {\n    return data === \"true\" || data === \"True\" || data === \"TRUE\";\n}\nfunction isBoolean(object) {\n    return Object.prototype.toString.call(object) === \"[object Boolean]\";\n}\nvar bool = new type(\"tag:yaml.org,2002:bool\", {\n    kind: \"scalar\",\n    resolve: resolveYamlBoolean,\n    construct: constructYamlBoolean,\n    predicate: isBoolean,\n    represent: {\n        lowercase: function(object) {\n            return object ? \"true\" : \"false\";\n        },\n        uppercase: function(object) {\n            return object ? \"TRUE\" : \"FALSE\";\n        },\n        camelcase: function(object) {\n            return object ? \"True\" : \"False\";\n        }\n    },\n    defaultStyle: \"lowercase\"\n});\nfunction isHexCode(c) {\n    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */  || 0x41 /* A */  <= c && c <= 0x46 /* F */  || 0x61 /* a */  <= c && c <= 0x66 /* f */ ;\n}\nfunction isOctCode(c) {\n    return 0x30 /* 0 */  <= c && c <= 0x37 /* 7 */ ;\n}\nfunction isDecCode(c) {\n    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ;\n}\nfunction resolveYamlInteger(data) {\n    if (data === null) return false;\n    var max = data.length, index = 0, hasDigits = false, ch;\n    if (!max) return false;\n    ch = data[index];\n    // sign\n    if (ch === \"-\" || ch === \"+\") {\n        ch = data[++index];\n    }\n    if (ch === \"0\") {\n        // 0\n        if (index + 1 === max) return true;\n        ch = data[++index];\n        // base 2, base 8, base 16\n        if (ch === \"b\") {\n            // base 2\n            index++;\n            for(; index < max; index++){\n                ch = data[index];\n                if (ch === \"_\") continue;\n                if (ch !== \"0\" && ch !== \"1\") return false;\n                hasDigits = true;\n            }\n            return hasDigits && ch !== \"_\";\n        }\n        if (ch === \"x\") {\n            // base 16\n            index++;\n            for(; index < max; index++){\n                ch = data[index];\n                if (ch === \"_\") continue;\n                if (!isHexCode(data.charCodeAt(index))) return false;\n                hasDigits = true;\n            }\n            return hasDigits && ch !== \"_\";\n        }\n        if (ch === \"o\") {\n            // base 8\n            index++;\n            for(; index < max; index++){\n                ch = data[index];\n                if (ch === \"_\") continue;\n                if (!isOctCode(data.charCodeAt(index))) return false;\n                hasDigits = true;\n            }\n            return hasDigits && ch !== \"_\";\n        }\n    }\n    // base 10 (except 0)\n    // value should not start with `_`;\n    if (ch === \"_\") return false;\n    for(; index < max; index++){\n        ch = data[index];\n        if (ch === \"_\") continue;\n        if (!isDecCode(data.charCodeAt(index))) {\n            return false;\n        }\n        hasDigits = true;\n    }\n    // Should have digits and should not end with `_`\n    if (!hasDigits || ch === \"_\") return false;\n    return true;\n}\nfunction constructYamlInteger(data) {\n    var value = data, sign = 1, ch;\n    if (value.indexOf(\"_\") !== -1) {\n        value = value.replace(/_/g, \"\");\n    }\n    ch = value[0];\n    if (ch === \"-\" || ch === \"+\") {\n        if (ch === \"-\") sign = -1;\n        value = value.slice(1);\n        ch = value[0];\n    }\n    if (value === \"0\") return 0;\n    if (ch === \"0\") {\n        if (value[1] === \"b\") return sign * parseInt(value.slice(2), 2);\n        if (value[1] === \"x\") return sign * parseInt(value.slice(2), 16);\n        if (value[1] === \"o\") return sign * parseInt(value.slice(2), 8);\n    }\n    return sign * parseInt(value, 10);\n}\nfunction isInteger(object) {\n    return Object.prototype.toString.call(object) === \"[object Number]\" && object % 1 === 0 && !common.isNegativeZero(object);\n}\nvar int = new type(\"tag:yaml.org,2002:int\", {\n    kind: \"scalar\",\n    resolve: resolveYamlInteger,\n    construct: constructYamlInteger,\n    predicate: isInteger,\n    represent: {\n        binary: function(obj) {\n            return obj >= 0 ? \"0b\" + obj.toString(2) : \"-0b\" + obj.toString(2).slice(1);\n        },\n        octal: function(obj) {\n            return obj >= 0 ? \"0o\" + obj.toString(8) : \"-0o\" + obj.toString(8).slice(1);\n        },\n        decimal: function(obj) {\n            return obj.toString(10);\n        },\n        /* eslint-disable max-len */ hexadecimal: function(obj) {\n            return obj >= 0 ? \"0x\" + obj.toString(16).toUpperCase() : \"-0x\" + obj.toString(16).toUpperCase().slice(1);\n        }\n    },\n    defaultStyle: \"decimal\",\n    styleAliases: {\n        binary: [\n            2,\n            \"bin\"\n        ],\n        octal: [\n            8,\n            \"oct\"\n        ],\n        decimal: [\n            10,\n            \"dec\"\n        ],\n        hexadecimal: [\n            16,\n            \"hex\"\n        ]\n    }\n});\nvar YAML_FLOAT_PATTERN = new RegExp(// 2.5e4, 2.5 and integers\n\"^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?\" + // .2e4, .2\n// special case, seems not from spec\n\"|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?\" + // .inf\n\"|[-+]?\\\\.(?:inf|Inf|INF)\" + // .nan\n\"|\\\\.(?:nan|NaN|NAN))$\");\nfunction resolveYamlFloat(data) {\n    if (data === null) return false;\n    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`\n    // Probably should update regexp & check speed\n    data[data.length - 1] === \"_\") {\n        return false;\n    }\n    return true;\n}\nfunction constructYamlFloat(data) {\n    var value, sign;\n    value = data.replace(/_/g, \"\").toLowerCase();\n    sign = value[0] === \"-\" ? -1 : 1;\n    if (\"+-\".indexOf(value[0]) >= 0) {\n        value = value.slice(1);\n    }\n    if (value === \".inf\") {\n        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n    } else if (value === \".nan\") {\n        return NaN;\n    }\n    return sign * parseFloat(value, 10);\n}\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\nfunction representYamlFloat(object, style) {\n    var res;\n    if (isNaN(object)) {\n        switch(style){\n            case \"lowercase\":\n                return \".nan\";\n            case \"uppercase\":\n                return \".NAN\";\n            case \"camelcase\":\n                return \".NaN\";\n        }\n    } else if (Number.POSITIVE_INFINITY === object) {\n        switch(style){\n            case \"lowercase\":\n                return \".inf\";\n            case \"uppercase\":\n                return \".INF\";\n            case \"camelcase\":\n                return \".Inf\";\n        }\n    } else if (Number.NEGATIVE_INFINITY === object) {\n        switch(style){\n            case \"lowercase\":\n                return \"-.inf\";\n            case \"uppercase\":\n                return \"-.INF\";\n            case \"camelcase\":\n                return \"-.Inf\";\n        }\n    } else if (common.isNegativeZero(object)) {\n        return \"-0.0\";\n    }\n    res = object.toString(10);\n    // JS stringifier can build scientific format without dots: 5e-100,\n    // while YAML requres dot: 5.e-100. Fix it with simple hack\n    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace(\"e\", \".e\") : res;\n}\nfunction isFloat(object) {\n    return Object.prototype.toString.call(object) === \"[object Number]\" && (object % 1 !== 0 || common.isNegativeZero(object));\n}\nvar float = new type(\"tag:yaml.org,2002:float\", {\n    kind: \"scalar\",\n    resolve: resolveYamlFloat,\n    construct: constructYamlFloat,\n    predicate: isFloat,\n    represent: representYamlFloat,\n    defaultStyle: \"lowercase\"\n});\nvar json = failsafe.extend({\n    implicit: [\n        _null,\n        bool,\n        int,\n        float\n    ]\n});\nvar core = json;\nvar YAML_DATE_REGEXP = new RegExp(\"^([0-9][0-9][0-9][0-9])\" + // [1] year\n\"-([0-9][0-9])\" + // [2] month\n\"-([0-9][0-9])$\"); // [3] day\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\"^([0-9][0-9][0-9][0-9])\" + // [1] year\n\"-([0-9][0-9]?)\" + // [2] month\n\"-([0-9][0-9]?)\" + // [3] day\n\"(?:[Tt]|[ \\\\t]+)\" + // ...\n\"([0-9][0-9]?)\" + // [4] hour\n\":([0-9][0-9])\" + // [5] minute\n\":([0-9][0-9])\" + // [6] second\n\"(?:\\\\.([0-9]*))?\" + // [7] fraction\n\"(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)\" + // [8] tz [9] tz_sign [10] tz_hour\n\"(?::([0-9][0-9]))?))?$\"); // [11] tz_minute\nfunction resolveYamlTimestamp(data) {\n    if (data === null) return false;\n    if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n    return false;\n}\nfunction constructYamlTimestamp(data) {\n    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;\n    match = YAML_DATE_REGEXP.exec(data);\n    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n    if (match === null) throw new Error(\"Date resolve error\");\n    // match: [1] year [2] month [3] day\n    year = +match[1];\n    month = +match[2] - 1; // JS month starts with 0\n    day = +match[3];\n    if (!match[4]) {\n        return new Date(Date.UTC(year, month, day));\n    }\n    // match: [4] hour [5] minute [6] second [7] fraction\n    hour = +match[4];\n    minute = +match[5];\n    second = +match[6];\n    if (match[7]) {\n        fraction = match[7].slice(0, 3);\n        while(fraction.length < 3){\n            fraction += \"0\";\n        }\n        fraction = +fraction;\n    }\n    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n    if (match[9]) {\n        tz_hour = +match[10];\n        tz_minute = +(match[11] || 0);\n        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n        if (match[9] === \"-\") delta = -delta;\n    }\n    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n    if (delta) date.setTime(date.getTime() - delta);\n    return date;\n}\nfunction representYamlTimestamp(object /*, style*/ ) {\n    return object.toISOString();\n}\nvar timestamp = new type(\"tag:yaml.org,2002:timestamp\", {\n    kind: \"scalar\",\n    resolve: resolveYamlTimestamp,\n    construct: constructYamlTimestamp,\n    instanceOf: Date,\n    represent: representYamlTimestamp\n});\nfunction resolveYamlMerge(data) {\n    return data === \"<<\" || data === null;\n}\nvar merge = new type(\"tag:yaml.org,2002:merge\", {\n    kind: \"scalar\",\n    resolve: resolveYamlMerge\n});\n/*eslint-disable no-bitwise*/ // [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r\";\nfunction resolveYamlBinary(data) {\n    if (data === null) return false;\n    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n    // Convert one by one.\n    for(idx = 0; idx < max; idx++){\n        code = map.indexOf(data.charAt(idx));\n        // Skip CR/LF\n        if (code > 64) continue;\n        // Fail on illegal characters\n        if (code < 0) return false;\n        bitlen += 6;\n    }\n    // If there are any bits left, source was corrupted\n    return bitlen % 8 === 0;\n}\nfunction constructYamlBinary(data) {\n    var idx, tailbits, input = data.replace(/[\\r\\n=]/g, \"\"), max = input.length, map = BASE64_MAP, bits = 0, result = [];\n    // Collect by 6*4 bits (3 bytes)\n    for(idx = 0; idx < max; idx++){\n        if (idx % 4 === 0 && idx) {\n            result.push(bits >> 16 & 0xFF);\n            result.push(bits >> 8 & 0xFF);\n            result.push(bits & 0xFF);\n        }\n        bits = bits << 6 | map.indexOf(input.charAt(idx));\n    }\n    // Dump tail\n    tailbits = max % 4 * 6;\n    if (tailbits === 0) {\n        result.push(bits >> 16 & 0xFF);\n        result.push(bits >> 8 & 0xFF);\n        result.push(bits & 0xFF);\n    } else if (tailbits === 18) {\n        result.push(bits >> 10 & 0xFF);\n        result.push(bits >> 2 & 0xFF);\n    } else if (tailbits === 12) {\n        result.push(bits >> 4 & 0xFF);\n    }\n    return new Uint8Array(result);\n}\nfunction representYamlBinary(object /*, style*/ ) {\n    var result = \"\", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;\n    // Convert every three bytes to 4 ASCII characters.\n    for(idx = 0; idx < max; idx++){\n        if (idx % 3 === 0 && idx) {\n            result += map[bits >> 18 & 0x3F];\n            result += map[bits >> 12 & 0x3F];\n            result += map[bits >> 6 & 0x3F];\n            result += map[bits & 0x3F];\n        }\n        bits = (bits << 8) + object[idx];\n    }\n    // Dump tail\n    tail = max % 3;\n    if (tail === 0) {\n        result += map[bits >> 18 & 0x3F];\n        result += map[bits >> 12 & 0x3F];\n        result += map[bits >> 6 & 0x3F];\n        result += map[bits & 0x3F];\n    } else if (tail === 2) {\n        result += map[bits >> 10 & 0x3F];\n        result += map[bits >> 4 & 0x3F];\n        result += map[bits << 2 & 0x3F];\n        result += map[64];\n    } else if (tail === 1) {\n        result += map[bits >> 2 & 0x3F];\n        result += map[bits << 4 & 0x3F];\n        result += map[64];\n        result += map[64];\n    }\n    return result;\n}\nfunction isBinary(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Uint8Array]\";\n}\nvar binary = new type(\"tag:yaml.org,2002:binary\", {\n    kind: \"scalar\",\n    resolve: resolveYamlBinary,\n    construct: constructYamlBinary,\n    predicate: isBinary,\n    represent: representYamlBinary\n});\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar _toString$2 = Object.prototype.toString;\nfunction resolveYamlOmap(data) {\n    if (data === null) return true;\n    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;\n    for(index = 0, length = object.length; index < length; index += 1){\n        pair = object[index];\n        pairHasKey = false;\n        if (_toString$2.call(pair) !== \"[object Object]\") return false;\n        for(pairKey in pair){\n            if (_hasOwnProperty$3.call(pair, pairKey)) {\n                if (!pairHasKey) pairHasKey = true;\n                else return false;\n            }\n        }\n        if (!pairHasKey) return false;\n        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n        else return false;\n    }\n    return true;\n}\nfunction constructYamlOmap(data) {\n    return data !== null ? data : [];\n}\nvar omap = new type(\"tag:yaml.org,2002:omap\", {\n    kind: \"sequence\",\n    resolve: resolveYamlOmap,\n    construct: constructYamlOmap\n});\nvar _toString$1 = Object.prototype.toString;\nfunction resolveYamlPairs(data) {\n    if (data === null) return true;\n    var index, length, pair, keys, result, object = data;\n    result = new Array(object.length);\n    for(index = 0, length = object.length; index < length; index += 1){\n        pair = object[index];\n        if (_toString$1.call(pair) !== \"[object Object]\") return false;\n        keys = Object.keys(pair);\n        if (keys.length !== 1) return false;\n        result[index] = [\n            keys[0],\n            pair[keys[0]]\n        ];\n    }\n    return true;\n}\nfunction constructYamlPairs(data) {\n    if (data === null) return [];\n    var index, length, pair, keys, result, object = data;\n    result = new Array(object.length);\n    for(index = 0, length = object.length; index < length; index += 1){\n        pair = object[index];\n        keys = Object.keys(pair);\n        result[index] = [\n            keys[0],\n            pair[keys[0]]\n        ];\n    }\n    return result;\n}\nvar pairs = new type(\"tag:yaml.org,2002:pairs\", {\n    kind: \"sequence\",\n    resolve: resolveYamlPairs,\n    construct: constructYamlPairs\n});\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\nfunction resolveYamlSet(data) {\n    if (data === null) return true;\n    var key, object = data;\n    for(key in object){\n        if (_hasOwnProperty$2.call(object, key)) {\n            if (object[key] !== null) return false;\n        }\n    }\n    return true;\n}\nfunction constructYamlSet(data) {\n    return data !== null ? data : {};\n}\nvar set = new type(\"tag:yaml.org,2002:set\", {\n    kind: \"mapping\",\n    resolve: resolveYamlSet,\n    construct: constructYamlSet\n});\nvar _default = core.extend({\n    implicit: [\n        timestamp,\n        merge\n    ],\n    explicit: [\n        binary,\n        omap,\n        pairs,\n        set\n    ]\n});\n/*eslint-disable max-len,no-use-before-define*/ var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\nvar CONTEXT_FLOW_IN = 1;\nvar CONTEXT_FLOW_OUT = 2;\nvar CONTEXT_BLOCK_IN = 3;\nvar CONTEXT_BLOCK_OUT = 4;\nvar CHOMPING_CLIP = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP = 3;\nvar PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\nfunction _class(obj) {\n    return Object.prototype.toString.call(obj);\n}\nfunction is_EOL(c) {\n    return c === 0x0A /* LF */  || c === 0x0D /* CR */ ;\n}\nfunction is_WHITE_SPACE(c) {\n    return c === 0x09 /* Tab */  || c === 0x20 /* Space */ ;\n}\nfunction is_WS_OR_EOL(c) {\n    return c === 0x09 /* Tab */  || c === 0x20 /* Space */  || c === 0x0A /* LF */  || c === 0x0D /* CR */ ;\n}\nfunction is_FLOW_INDICATOR(c) {\n    return c === 0x2C /* , */  || c === 0x5B /* [ */  || c === 0x5D /* ] */  || c === 0x7B /* { */  || c === 0x7D /* } */ ;\n}\nfunction fromHexCode(c) {\n    var lc;\n    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) {\n        return c - 0x30;\n    }\n    /*eslint-disable no-bitwise*/ lc = c | 0x20;\n    if (0x61 /* a */  <= lc && lc <= 0x66 /* f */ ) {\n        return lc - 0x61 + 10;\n    }\n    return -1;\n}\nfunction escapedHexLen(c) {\n    if (c === 0x78 /* x */ ) {\n        return 2;\n    }\n    if (c === 0x75 /* u */ ) {\n        return 4;\n    }\n    if (c === 0x55 /* U */ ) {\n        return 8;\n    }\n    return 0;\n}\nfunction fromDecimalCode(c) {\n    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) {\n        return c - 0x30;\n    }\n    return -1;\n}\nfunction simpleEscapeSequence(c) {\n    /* eslint-disable indent */ return c === 0x30 /* 0 */  ? \"\\x00\" : c === 0x61 /* a */  ? \"\\x07\" : c === 0x62 /* b */  ? \"\\b\" : c === 0x74 /* t */  ? \"\t\" : c === 0x09 /* Tab */  ? \"\t\" : c === 0x6E /* n */  ? \"\\n\" : c === 0x76 /* v */  ? \"\\v\" : c === 0x66 /* f */  ? \"\\f\" : c === 0x72 /* r */  ? \"\\r\" : c === 0x65 /* e */  ? \"\\x1b\" : c === 0x20 /* Space */  ? \" \" : c === 0x22 /* \" */  ? '\"' : c === 0x2F /* / */  ? \"/\" : c === 0x5C /* \\ */  ? \"\\\\\" : c === 0x4E /* N */  ? \"\\x85\" : c === 0x5F /* _ */  ? \"\\xa0\" : c === 0x4C /* L */  ? \"\\u2028\" : c === 0x50 /* P */  ? \"\\u2029\" : \"\";\n}\nfunction charFromCodepoint(c) {\n    if (c <= 0xFFFF) {\n        return String.fromCharCode(c);\n    }\n    // Encode UTF-16 surrogate pair\n    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);\n}\n// set a property of a literal object, while protecting against prototype pollution,\n// see https://github.com/nodeca/js-yaml/issues/164 for more details\nfunction setProperty(object, key, value) {\n    // used for this specific key only because Object.defineProperty is slow\n    if (key === \"__proto__\") {\n        Object.defineProperty(object, key, {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: value\n        });\n    } else {\n        object[key] = value;\n    }\n}\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor(var i = 0; i < 256; i++){\n    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n    simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\nfunction State$1(input, options) {\n    this.input = input;\n    this.filename = options[\"filename\"] || null;\n    this.schema = options[\"schema\"] || _default;\n    this.onWarning = options[\"onWarning\"] || null;\n    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n    // if such documents have no explicit %YAML directive\n    this.legacy = options[\"legacy\"] || false;\n    this.json = options[\"json\"] || false;\n    this.listener = options[\"listener\"] || null;\n    this.implicitTypes = this.schema.compiledImplicit;\n    this.typeMap = this.schema.compiledTypeMap;\n    this.length = input.length;\n    this.position = 0;\n    this.line = 0;\n    this.lineStart = 0;\n    this.lineIndent = 0;\n    // position of first leading tab in the current line,\n    // used to make sure there are no tabs in the indentation\n    this.firstTabInLine = -1;\n    this.documents = [];\n/*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/ }\nfunction generateError(state, message) {\n    var mark = {\n        name: state.filename,\n        buffer: state.input.slice(0, -1),\n        position: state.position,\n        line: state.line,\n        column: state.position - state.lineStart\n    };\n    mark.snippet = snippet(mark);\n    return new exception(message, mark);\n}\nfunction throwError(state, message) {\n    throw generateError(state, message);\n}\nfunction throwWarning(state, message) {\n    if (state.onWarning) {\n        state.onWarning.call(null, generateError(state, message));\n    }\n}\nvar directiveHandlers = {\n    YAML: function handleYamlDirective(state, name, args) {\n        var match, major, minor;\n        if (state.version !== null) {\n            throwError(state, \"duplication of %YAML directive\");\n        }\n        if (args.length !== 1) {\n            throwError(state, \"YAML directive accepts exactly one argument\");\n        }\n        match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n        if (match === null) {\n            throwError(state, \"ill-formed argument of the YAML directive\");\n        }\n        major = parseInt(match[1], 10);\n        minor = parseInt(match[2], 10);\n        if (major !== 1) {\n            throwError(state, \"unacceptable YAML version of the document\");\n        }\n        state.version = args[0];\n        state.checkLineBreaks = minor < 2;\n        if (minor !== 1 && minor !== 2) {\n            throwWarning(state, \"unsupported YAML version of the document\");\n        }\n    },\n    TAG: function handleTagDirective(state, name, args) {\n        var handle, prefix;\n        if (args.length !== 2) {\n            throwError(state, \"TAG directive accepts exactly two arguments\");\n        }\n        handle = args[0];\n        prefix = args[1];\n        if (!PATTERN_TAG_HANDLE.test(handle)) {\n            throwError(state, \"ill-formed tag handle (first argument) of the TAG directive\");\n        }\n        if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n            throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n        }\n        if (!PATTERN_TAG_URI.test(prefix)) {\n            throwError(state, \"ill-formed tag prefix (second argument) of the TAG directive\");\n        }\n        try {\n            prefix = decodeURIComponent(prefix);\n        } catch (err) {\n            throwError(state, \"tag prefix is malformed: \" + prefix);\n        }\n        state.tagMap[handle] = prefix;\n    }\n};\nfunction captureSegment(state, start, end, checkJson) {\n    var _position, _length, _character, _result;\n    if (start < end) {\n        _result = state.input.slice(start, end);\n        if (checkJson) {\n            for(_position = 0, _length = _result.length; _position < _length; _position += 1){\n                _character = _result.charCodeAt(_position);\n                if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {\n                    throwError(state, \"expected valid JSON character\");\n                }\n            }\n        } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n            throwError(state, \"the stream contains non-printable characters\");\n        }\n        state.result += _result;\n    }\n}\nfunction mergeMappings(state, destination, source, overridableKeys) {\n    var sourceKeys, key, index, quantity;\n    if (!common.isObject(source)) {\n        throwError(state, \"cannot merge mappings; the provided source object is unacceptable\");\n    }\n    sourceKeys = Object.keys(source);\n    for(index = 0, quantity = sourceKeys.length; index < quantity; index += 1){\n        key = sourceKeys[index];\n        if (!_hasOwnProperty$1.call(destination, key)) {\n            setProperty(destination, key, source[key]);\n            overridableKeys[key] = true;\n        }\n    }\n}\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {\n    var index, quantity;\n    // The output is a plain object here, so keys can only be strings.\n    // We need to convert keyNode to a string, but doing so can hang the process\n    // (deeply nested arrays that explode exponentially using aliases).\n    if (Array.isArray(keyNode)) {\n        keyNode = Array.prototype.slice.call(keyNode);\n        for(index = 0, quantity = keyNode.length; index < quantity; index += 1){\n            if (Array.isArray(keyNode[index])) {\n                throwError(state, \"nested arrays are not supported inside keys\");\n            }\n            if (typeof keyNode === \"object\" && _class(keyNode[index]) === \"[object Object]\") {\n                keyNode[index] = \"[object Object]\";\n            }\n        }\n    }\n    // Avoid code execution in load() via toString property\n    // (still use its own toString for arrays, timestamps,\n    // and whatever user schema extensions happen to have @@toStringTag)\n    if (typeof keyNode === \"object\" && _class(keyNode) === \"[object Object]\") {\n        keyNode = \"[object Object]\";\n    }\n    keyNode = String(keyNode);\n    if (_result === null) {\n        _result = {};\n    }\n    if (keyTag === \"tag:yaml.org,2002:merge\") {\n        if (Array.isArray(valueNode)) {\n            for(index = 0, quantity = valueNode.length; index < quantity; index += 1){\n                mergeMappings(state, _result, valueNode[index], overridableKeys);\n            }\n        } else {\n            mergeMappings(state, _result, valueNode, overridableKeys);\n        }\n    } else {\n        if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {\n            state.line = startLine || state.line;\n            state.lineStart = startLineStart || state.lineStart;\n            state.position = startPos || state.position;\n            throwError(state, \"duplicated mapping key\");\n        }\n        setProperty(_result, keyNode, valueNode);\n        delete overridableKeys[keyNode];\n    }\n    return _result;\n}\nfunction readLineBreak(state) {\n    var ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch === 0x0A /* LF */ ) {\n        state.position++;\n    } else if (ch === 0x0D /* CR */ ) {\n        state.position++;\n        if (state.input.charCodeAt(state.position) === 0x0A /* LF */ ) {\n            state.position++;\n        }\n    } else {\n        throwError(state, \"a line break is expected\");\n    }\n    state.line += 1;\n    state.lineStart = state.position;\n    state.firstTabInLine = -1;\n}\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);\n    while(ch !== 0){\n        while(is_WHITE_SPACE(ch)){\n            if (ch === 0x09 /* Tab */  && state.firstTabInLine === -1) {\n                state.firstTabInLine = state.position;\n            }\n            ch = state.input.charCodeAt(++state.position);\n        }\n        if (allowComments && ch === 0x23 /* # */ ) {\n            do {\n                ch = state.input.charCodeAt(++state.position);\n            }while (ch !== 0x0A /* LF */  && ch !== 0x0D /* CR */  && ch !== 0);\n        }\n        if (is_EOL(ch)) {\n            readLineBreak(state);\n            ch = state.input.charCodeAt(state.position);\n            lineBreaks++;\n            state.lineIndent = 0;\n            while(ch === 0x20 /* Space */ ){\n                state.lineIndent++;\n                ch = state.input.charCodeAt(++state.position);\n            }\n        } else {\n            break;\n        }\n    }\n    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n        throwWarning(state, \"deficient indentation\");\n    }\n    return lineBreaks;\n}\nfunction testDocumentSeparator(state) {\n    var _position = state.position, ch;\n    ch = state.input.charCodeAt(_position);\n    // Condition state.position === state.lineStart is tested\n    // in parent on each call, for efficiency. No needs to test here again.\n    if ((ch === 0x2D /* - */  || ch === 0x2E /* . */ ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n        _position += 3;\n        ch = state.input.charCodeAt(_position);\n        if (ch === 0 || is_WS_OR_EOL(ch)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction writeFoldedLines(state, count) {\n    if (count === 1) {\n        state.result += \" \";\n    } else if (count > 1) {\n        state.result += common.repeat(\"\\n\", count - 1);\n    }\n}\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */  || ch === 0x26 /* & */  || ch === 0x2A /* * */  || ch === 0x21 /* ! */  || ch === 0x7C /* | */  || ch === 0x3E /* > */  || ch === 0x27 /* ' */  || ch === 0x22 /* \" */  || ch === 0x25 /* % */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */ ) {\n        return false;\n    }\n    if (ch === 0x3F /* ? */  || ch === 0x2D /* - */ ) {\n        following = state.input.charCodeAt(state.position + 1);\n        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n            return false;\n        }\n    }\n    state.kind = \"scalar\";\n    state.result = \"\";\n    captureStart = captureEnd = state.position;\n    hasPendingContent = false;\n    while(ch !== 0){\n        if (ch === 0x3A /* : */ ) {\n            following = state.input.charCodeAt(state.position + 1);\n            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n                break;\n            }\n        } else if (ch === 0x23 /* # */ ) {\n            preceding = state.input.charCodeAt(state.position - 1);\n            if (is_WS_OR_EOL(preceding)) {\n                break;\n            }\n        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n            break;\n        } else if (is_EOL(ch)) {\n            _line = state.line;\n            _lineStart = state.lineStart;\n            _lineIndent = state.lineIndent;\n            skipSeparationSpace(state, false, -1);\n            if (state.lineIndent >= nodeIndent) {\n                hasPendingContent = true;\n                ch = state.input.charCodeAt(state.position);\n                continue;\n            } else {\n                state.position = captureEnd;\n                state.line = _line;\n                state.lineStart = _lineStart;\n                state.lineIndent = _lineIndent;\n                break;\n            }\n        }\n        if (hasPendingContent) {\n            captureSegment(state, captureStart, captureEnd, false);\n            writeFoldedLines(state, state.line - _line);\n            captureStart = captureEnd = state.position;\n            hasPendingContent = false;\n        }\n        if (!is_WHITE_SPACE(ch)) {\n            captureEnd = state.position + 1;\n        }\n        ch = state.input.charCodeAt(++state.position);\n    }\n    captureSegment(state, captureStart, captureEnd, false);\n    if (state.result) {\n        return true;\n    }\n    state.kind = _kind;\n    state.result = _result;\n    return false;\n}\nfunction readSingleQuotedScalar(state, nodeIndent) {\n    var ch, captureStart, captureEnd;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x27 /* ' */ ) {\n        return false;\n    }\n    state.kind = \"scalar\";\n    state.result = \"\";\n    state.position++;\n    captureStart = captureEnd = state.position;\n    while((ch = state.input.charCodeAt(state.position)) !== 0){\n        if (ch === 0x27 /* ' */ ) {\n            captureSegment(state, captureStart, state.position, true);\n            ch = state.input.charCodeAt(++state.position);\n            if (ch === 0x27 /* ' */ ) {\n                captureStart = state.position;\n                state.position++;\n                captureEnd = state.position;\n            } else {\n                return true;\n            }\n        } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, \"unexpected end of the document within a single quoted scalar\");\n        } else {\n            state.position++;\n            captureEnd = state.position;\n        }\n    }\n    throwError(state, \"unexpected end of the stream within a single quoted scalar\");\n}\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x22 /* \" */ ) {\n        return false;\n    }\n    state.kind = \"scalar\";\n    state.result = \"\";\n    state.position++;\n    captureStart = captureEnd = state.position;\n    while((ch = state.input.charCodeAt(state.position)) !== 0){\n        if (ch === 0x22 /* \" */ ) {\n            captureSegment(state, captureStart, state.position, true);\n            state.position++;\n            return true;\n        } else if (ch === 0x5C /* \\ */ ) {\n            captureSegment(state, captureStart, state.position, true);\n            ch = state.input.charCodeAt(++state.position);\n            if (is_EOL(ch)) {\n                skipSeparationSpace(state, false, nodeIndent);\n            // TODO: rework to inline fn with no type cast?\n            } else if (ch < 256 && simpleEscapeCheck[ch]) {\n                state.result += simpleEscapeMap[ch];\n                state.position++;\n            } else if ((tmp = escapedHexLen(ch)) > 0) {\n                hexLength = tmp;\n                hexResult = 0;\n                for(; hexLength > 0; hexLength--){\n                    ch = state.input.charCodeAt(++state.position);\n                    if ((tmp = fromHexCode(ch)) >= 0) {\n                        hexResult = (hexResult << 4) + tmp;\n                    } else {\n                        throwError(state, \"expected hexadecimal character\");\n                    }\n                }\n                state.result += charFromCodepoint(hexResult);\n                state.position++;\n            } else {\n                throwError(state, \"unknown escape sequence\");\n            }\n            captureStart = captureEnd = state.position;\n        } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, \"unexpected end of the document within a double quoted scalar\");\n        } else {\n            state.position++;\n            captureEnd = state.position;\n        }\n    }\n    throwError(state, \"unexpected end of the stream within a double quoted scalar\");\n}\nfunction readFlowCollection(state, nodeIndent) {\n    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch === 0x5B /* [ */ ) {\n        terminator = 0x5D; /* ] */ \n        isMapping = false;\n        _result = [];\n    } else if (ch === 0x7B /* { */ ) {\n        terminator = 0x7D; /* } */ \n        isMapping = true;\n        _result = {};\n    } else {\n        return false;\n    }\n    if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n    }\n    ch = state.input.charCodeAt(++state.position);\n    while(ch !== 0){\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if (ch === terminator) {\n            state.position++;\n            state.tag = _tag;\n            state.anchor = _anchor;\n            state.kind = isMapping ? \"mapping\" : \"sequence\";\n            state.result = _result;\n            return true;\n        } else if (!readNext) {\n            throwError(state, \"missed comma between flow collection entries\");\n        } else if (ch === 0x2C /* , */ ) {\n            // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n            throwError(state, \"expected the node content, but found ','\");\n        }\n        keyTag = keyNode = valueNode = null;\n        isPair = isExplicitPair = false;\n        if (ch === 0x3F /* ? */ ) {\n            following = state.input.charCodeAt(state.position + 1);\n            if (is_WS_OR_EOL(following)) {\n                isPair = isExplicitPair = true;\n                state.position++;\n                skipSeparationSpace(state, true, nodeIndent);\n            }\n        }\n        _line = state.line; // Save the current line.\n        _lineStart = state.lineStart;\n        _pos = state.position;\n        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n        keyTag = state.tag;\n        keyNode = state.result;\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */ ) {\n            isPair = true;\n            ch = state.input.charCodeAt(++state.position);\n            skipSeparationSpace(state, true, nodeIndent);\n            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n            valueNode = state.result;\n        }\n        if (isMapping) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n        } else if (isPair) {\n            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n        } else {\n            _result.push(keyNode);\n        }\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if (ch === 0x2C /* , */ ) {\n            readNext = true;\n            ch = state.input.charCodeAt(++state.position);\n        } else {\n            readNext = false;\n        }\n    }\n    throwError(state, \"unexpected end of the stream within a flow collection\");\n}\nfunction readBlockScalar(state, nodeIndent) {\n    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch === 0x7C /* | */ ) {\n        folding = false;\n    } else if (ch === 0x3E /* > */ ) {\n        folding = true;\n    } else {\n        return false;\n    }\n    state.kind = \"scalar\";\n    state.result = \"\";\n    while(ch !== 0){\n        ch = state.input.charCodeAt(++state.position);\n        if (ch === 0x2B /* + */  || ch === 0x2D /* - */ ) {\n            if (CHOMPING_CLIP === chomping) {\n                chomping = ch === 0x2B /* + */  ? CHOMPING_KEEP : CHOMPING_STRIP;\n            } else {\n                throwError(state, \"repeat of a chomping mode identifier\");\n            }\n        } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n            if (tmp === 0) {\n                throwError(state, \"bad explicit indentation width of a block scalar; it cannot be less than one\");\n            } else if (!detectedIndent) {\n                textIndent = nodeIndent + tmp - 1;\n                detectedIndent = true;\n            } else {\n                throwError(state, \"repeat of an indentation width identifier\");\n            }\n        } else {\n            break;\n        }\n    }\n    if (is_WHITE_SPACE(ch)) {\n        do {\n            ch = state.input.charCodeAt(++state.position);\n        }while (is_WHITE_SPACE(ch));\n        if (ch === 0x23 /* # */ ) {\n            do {\n                ch = state.input.charCodeAt(++state.position);\n            }while (!is_EOL(ch) && ch !== 0);\n        }\n    }\n    while(ch !== 0){\n        readLineBreak(state);\n        state.lineIndent = 0;\n        ch = state.input.charCodeAt(state.position);\n        while((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */ ){\n            state.lineIndent++;\n            ch = state.input.charCodeAt(++state.position);\n        }\n        if (!detectedIndent && state.lineIndent > textIndent) {\n            textIndent = state.lineIndent;\n        }\n        if (is_EOL(ch)) {\n            emptyLines++;\n            continue;\n        }\n        // End of the scalar.\n        if (state.lineIndent < textIndent) {\n            // Perform the chomping.\n            if (chomping === CHOMPING_KEEP) {\n                state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n            } else if (chomping === CHOMPING_CLIP) {\n                if (didReadContent) {\n                    state.result += \"\\n\";\n                }\n            }\n            break;\n        }\n        // Folded style: use fancy rules to handle line breaks.\n        if (folding) {\n            // Lines starting with white space characters (more-indented lines) are not folded.\n            if (is_WHITE_SPACE(ch)) {\n                atMoreIndented = true;\n                // except for the first content line (cf. Example 8.1)\n                state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n            // End of more-indented block.\n            } else if (atMoreIndented) {\n                atMoreIndented = false;\n                state.result += common.repeat(\"\\n\", emptyLines + 1);\n            // Just one line break - perceive as the same line.\n            } else if (emptyLines === 0) {\n                if (didReadContent) {\n                    state.result += \" \";\n                }\n            // Several line breaks - perceive as different lines.\n            } else {\n                state.result += common.repeat(\"\\n\", emptyLines);\n            }\n        // Literal style: just add exact number of line breaks between content lines.\n        } else {\n            // Keep all line breaks except the header line break.\n            state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n        }\n        didReadContent = true;\n        detectedIndent = true;\n        emptyLines = 0;\n        captureStart = state.position;\n        while(!is_EOL(ch) && ch !== 0){\n            ch = state.input.charCodeAt(++state.position);\n        }\n        captureSegment(state, captureStart, state.position, false);\n    }\n    return true;\n}\nfunction readBlockSequence(state, nodeIndent) {\n    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;\n    // there is a leading tab before this token, so it can't be a block sequence/mapping;\n    // it can still be flow sequence/mapping or a scalar\n    if (state.firstTabInLine !== -1) return false;\n    if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n    }\n    ch = state.input.charCodeAt(state.position);\n    while(ch !== 0){\n        if (state.firstTabInLine !== -1) {\n            state.position = state.firstTabInLine;\n            throwError(state, \"tab characters must not be used in indentation\");\n        }\n        if (ch !== 0x2D /* - */ ) {\n            break;\n        }\n        following = state.input.charCodeAt(state.position + 1);\n        if (!is_WS_OR_EOL(following)) {\n            break;\n        }\n        detected = true;\n        state.position++;\n        if (skipSeparationSpace(state, true, -1)) {\n            if (state.lineIndent <= nodeIndent) {\n                _result.push(null);\n                ch = state.input.charCodeAt(state.position);\n                continue;\n            }\n        }\n        _line = state.line;\n        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n        _result.push(state.result);\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n            throwError(state, \"bad indentation of a sequence entry\");\n        } else if (state.lineIndent < nodeIndent) {\n            break;\n        }\n    }\n    if (detected) {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = \"sequence\";\n        state.result = _result;\n        return true;\n    }\n    return false;\n}\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;\n    // there is a leading tab before this token, so it can't be a block sequence/mapping;\n    // it can still be flow sequence/mapping or a scalar\n    if (state.firstTabInLine !== -1) return false;\n    if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n    }\n    ch = state.input.charCodeAt(state.position);\n    while(ch !== 0){\n        if (!atExplicitKey && state.firstTabInLine !== -1) {\n            state.position = state.firstTabInLine;\n            throwError(state, \"tab characters must not be used in indentation\");\n        }\n        following = state.input.charCodeAt(state.position + 1);\n        _line = state.line; // Save the current line.\n        //\n        // Explicit notation case. There are two separate blocks:\n        // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n        //\n        if ((ch === 0x3F /* ? */  || ch === 0x3A /* : */ ) && is_WS_OR_EOL(following)) {\n            if (ch === 0x3F /* ? */ ) {\n                if (atExplicitKey) {\n                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n                    keyTag = keyNode = valueNode = null;\n                }\n                detected = true;\n                atExplicitKey = true;\n                allowCompact = true;\n            } else if (atExplicitKey) {\n                // i.e. 0x3A/* : */ === character after the explicit key.\n                atExplicitKey = false;\n                allowCompact = true;\n            } else {\n                throwError(state, \"incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line\");\n            }\n            state.position += 1;\n            ch = following;\n        //\n        // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n        //\n        } else {\n            _keyLine = state.line;\n            _keyLineStart = state.lineStart;\n            _keyPos = state.position;\n            if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n                break;\n            }\n            if (state.line === _line) {\n                ch = state.input.charCodeAt(state.position);\n                while(is_WHITE_SPACE(ch)){\n                    ch = state.input.charCodeAt(++state.position);\n                }\n                if (ch === 0x3A /* : */ ) {\n                    ch = state.input.charCodeAt(++state.position);\n                    if (!is_WS_OR_EOL(ch)) {\n                        throwError(state, \"a whitespace character is expected after the key-value separator within a block mapping\");\n                    }\n                    if (atExplicitKey) {\n                        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n                        keyTag = keyNode = valueNode = null;\n                    }\n                    detected = true;\n                    atExplicitKey = false;\n                    allowCompact = false;\n                    keyTag = state.tag;\n                    keyNode = state.result;\n                } else if (detected) {\n                    throwError(state, \"can not read an implicit mapping pair; a colon is missed\");\n                } else {\n                    state.tag = _tag;\n                    state.anchor = _anchor;\n                    return true; // Keep the result of `composeNode`.\n                }\n            } else if (detected) {\n                throwError(state, \"can not read a block mapping entry; a multiline key may not be an implicit key\");\n            } else {\n                state.tag = _tag;\n                state.anchor = _anchor;\n                return true; // Keep the result of `composeNode`.\n            }\n        }\n        //\n        // Common reading code for both explicit and implicit notations.\n        //\n        if (state.line === _line || state.lineIndent > nodeIndent) {\n            if (atExplicitKey) {\n                _keyLine = state.line;\n                _keyLineStart = state.lineStart;\n                _keyPos = state.position;\n            }\n            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n                if (atExplicitKey) {\n                    keyNode = state.result;\n                } else {\n                    valueNode = state.result;\n                }\n            }\n            if (!atExplicitKey) {\n                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n                keyTag = keyNode = valueNode = null;\n            }\n            skipSeparationSpace(state, true, -1);\n            ch = state.input.charCodeAt(state.position);\n        }\n        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n            throwError(state, \"bad indentation of a mapping entry\");\n        } else if (state.lineIndent < nodeIndent) {\n            break;\n        }\n    }\n    //\n    // Epilogue.\n    //\n    // Special case: last mapping's node contains only the key in explicit notation.\n    if (atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n    }\n    // Expose the resulting mapping.\n    if (detected) {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = \"mapping\";\n        state.result = _result;\n    }\n    return detected;\n}\nfunction readTagProperty(state) {\n    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x21 /* ! */ ) return false;\n    if (state.tag !== null) {\n        throwError(state, \"duplication of a tag property\");\n    }\n    ch = state.input.charCodeAt(++state.position);\n    if (ch === 0x3C /* < */ ) {\n        isVerbatim = true;\n        ch = state.input.charCodeAt(++state.position);\n    } else if (ch === 0x21 /* ! */ ) {\n        isNamed = true;\n        tagHandle = \"!!\";\n        ch = state.input.charCodeAt(++state.position);\n    } else {\n        tagHandle = \"!\";\n    }\n    _position = state.position;\n    if (isVerbatim) {\n        do {\n            ch = state.input.charCodeAt(++state.position);\n        }while (ch !== 0 && ch !== 0x3E /* > */ );\n        if (state.position < state.length) {\n            tagName = state.input.slice(_position, state.position);\n            ch = state.input.charCodeAt(++state.position);\n        } else {\n            throwError(state, \"unexpected end of the stream within a verbatim tag\");\n        }\n    } else {\n        while(ch !== 0 && !is_WS_OR_EOL(ch)){\n            if (ch === 0x21 /* ! */ ) {\n                if (!isNamed) {\n                    tagHandle = state.input.slice(_position - 1, state.position + 1);\n                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n                        throwError(state, \"named tag handle cannot contain such characters\");\n                    }\n                    isNamed = true;\n                    _position = state.position + 1;\n                } else {\n                    throwError(state, \"tag suffix cannot contain exclamation marks\");\n                }\n            }\n            ch = state.input.charCodeAt(++state.position);\n        }\n        tagName = state.input.slice(_position, state.position);\n        if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n            throwError(state, \"tag suffix cannot contain flow indicator characters\");\n        }\n    }\n    if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n        throwError(state, \"tag name cannot contain such characters: \" + tagName);\n    }\n    try {\n        tagName = decodeURIComponent(tagName);\n    } catch (err) {\n        throwError(state, \"tag name is malformed: \" + tagName);\n    }\n    if (isVerbatim) {\n        state.tag = tagName;\n    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n        state.tag = state.tagMap[tagHandle] + tagName;\n    } else if (tagHandle === \"!\") {\n        state.tag = \"!\" + tagName;\n    } else if (tagHandle === \"!!\") {\n        state.tag = \"tag:yaml.org,2002:\" + tagName;\n    } else {\n        throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n    }\n    return true;\n}\nfunction readAnchorProperty(state) {\n    var _position, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x26 /* & */ ) return false;\n    if (state.anchor !== null) {\n        throwError(state, \"duplication of an anchor property\");\n    }\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)){\n        ch = state.input.charCodeAt(++state.position);\n    }\n    if (state.position === _position) {\n        throwError(state, \"name of an anchor node must contain at least one character\");\n    }\n    state.anchor = state.input.slice(_position, state.position);\n    return true;\n}\nfunction readAlias(state) {\n    var _position, alias, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x2A /* * */ ) return false;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)){\n        ch = state.input.charCodeAt(++state.position);\n    }\n    if (state.position === _position) {\n        throwError(state, \"name of an alias node must contain at least one character\");\n    }\n    alias = state.input.slice(_position, state.position);\n    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n        throwError(state, 'unidentified alias \"' + alias + '\"');\n    }\n    state.result = state.anchorMap[alias];\n    skipSeparationSpace(state, true, -1);\n    return true;\n}\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;\n    if (state.listener !== null) {\n        state.listener(\"open\", state);\n    }\n    state.tag = null;\n    state.anchor = null;\n    state.kind = null;\n    state.result = null;\n    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n    if (allowToSeek) {\n        if (skipSeparationSpace(state, true, -1)) {\n            atNewLine = true;\n            if (state.lineIndent > parentIndent) {\n                indentStatus = 1;\n            } else if (state.lineIndent === parentIndent) {\n                indentStatus = 0;\n            } else if (state.lineIndent < parentIndent) {\n                indentStatus = -1;\n            }\n        }\n    }\n    if (indentStatus === 1) {\n        while(readTagProperty(state) || readAnchorProperty(state)){\n            if (skipSeparationSpace(state, true, -1)) {\n                atNewLine = true;\n                allowBlockCollections = allowBlockStyles;\n                if (state.lineIndent > parentIndent) {\n                    indentStatus = 1;\n                } else if (state.lineIndent === parentIndent) {\n                    indentStatus = 0;\n                } else if (state.lineIndent < parentIndent) {\n                    indentStatus = -1;\n                }\n            } else {\n                allowBlockCollections = false;\n            }\n        }\n    }\n    if (allowBlockCollections) {\n        allowBlockCollections = atNewLine || allowCompact;\n    }\n    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n            flowIndent = parentIndent;\n        } else {\n            flowIndent = parentIndent + 1;\n        }\n        blockIndent = state.position - state.lineStart;\n        if (indentStatus === 1) {\n            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n                hasContent = true;\n            } else {\n                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n                    hasContent = true;\n                } else if (readAlias(state)) {\n                    hasContent = true;\n                    if (state.tag !== null || state.anchor !== null) {\n                        throwError(state, \"alias node should not have any properties\");\n                    }\n                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n                    hasContent = true;\n                    if (state.tag === null) {\n                        state.tag = \"?\";\n                    }\n                }\n                if (state.anchor !== null) {\n                    state.anchorMap[state.anchor] = state.result;\n                }\n            }\n        } else if (indentStatus === 0) {\n            // Special case: block sequences are allowed to have same indentation level as the parent.\n            // http://www.yaml.org/spec/1.2/spec.html#id2799784\n            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n        }\n    }\n    if (state.tag === null) {\n        if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n        }\n    } else if (state.tag === \"?\") {\n        // Implicit resolving is not allowed for non-scalar types, and '?'\n        // non-specific tag is only automatically assigned to plain scalars.\n        //\n        // We only need to check kind conformity in case user explicitly assigns '?'\n        // tag, for example like this: \"!<?> [0]\"\n        //\n        if (state.result !== null && state.kind !== \"scalar\") {\n            throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n        }\n        for(typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1){\n            type = state.implicitTypes[typeIndex];\n            if (type.resolve(state.result)) {\n                state.result = type.construct(state.result);\n                state.tag = type.tag;\n                if (state.anchor !== null) {\n                    state.anchorMap[state.anchor] = state.result;\n                }\n                break;\n            }\n        }\n    } else if (state.tag !== \"!\") {\n        if (_hasOwnProperty$1.call(state.typeMap[state.kind || \"fallback\"], state.tag)) {\n            type = state.typeMap[state.kind || \"fallback\"][state.tag];\n        } else {\n            // looking for multi type\n            type = null;\n            typeList = state.typeMap.multi[state.kind || \"fallback\"];\n            for(typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1){\n                if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n                    type = typeList[typeIndex];\n                    break;\n                }\n            }\n        }\n        if (!type) {\n            throwError(state, \"unknown tag !<\" + state.tag + \">\");\n        }\n        if (state.result !== null && type.kind !== state.kind) {\n            throwError(state, \"unacceptable node kind for !<\" + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n        }\n        if (!type.resolve(state.result, state.tag)) {\n            throwError(state, \"cannot resolve a node with !<\" + state.tag + \"> explicit tag\");\n        } else {\n            state.result = type.construct(state.result, state.tag);\n            if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n            }\n        }\n    }\n    if (state.listener !== null) {\n        state.listener(\"close\", state);\n    }\n    return state.tag !== null || state.anchor !== null || hasContent;\n}\nfunction readDocument(state) {\n    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;\n    state.version = null;\n    state.checkLineBreaks = state.legacy;\n    state.tagMap = Object.create(null);\n    state.anchorMap = Object.create(null);\n    while((ch = state.input.charCodeAt(state.position)) !== 0){\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n        if (state.lineIndent > 0 || ch !== 0x25 /* % */ ) {\n            break;\n        }\n        hasDirectives = true;\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n        while(ch !== 0 && !is_WS_OR_EOL(ch)){\n            ch = state.input.charCodeAt(++state.position);\n        }\n        directiveName = state.input.slice(_position, state.position);\n        directiveArgs = [];\n        if (directiveName.length < 1) {\n            throwError(state, \"directive name must not be less than one character in length\");\n        }\n        while(ch !== 0){\n            while(is_WHITE_SPACE(ch)){\n                ch = state.input.charCodeAt(++state.position);\n            }\n            if (ch === 0x23 /* # */ ) {\n                do {\n                    ch = state.input.charCodeAt(++state.position);\n                }while (ch !== 0 && !is_EOL(ch));\n                break;\n            }\n            if (is_EOL(ch)) break;\n            _position = state.position;\n            while(ch !== 0 && !is_WS_OR_EOL(ch)){\n                ch = state.input.charCodeAt(++state.position);\n            }\n            directiveArgs.push(state.input.slice(_position, state.position));\n        }\n        if (ch !== 0) readLineBreak(state);\n        if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n            directiveHandlers[directiveName](state, directiveName, directiveArgs);\n        } else {\n            throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n        }\n    }\n    skipSeparationSpace(state, true, -1);\n    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */  && state.input.charCodeAt(state.position + 1) === 0x2D /* - */  && state.input.charCodeAt(state.position + 2) === 0x2D /* - */ ) {\n        state.position += 3;\n        skipSeparationSpace(state, true, -1);\n    } else if (hasDirectives) {\n        throwError(state, \"directives end mark is expected\");\n    }\n    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n    skipSeparationSpace(state, true, -1);\n    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n        throwWarning(state, \"non-ASCII line breaks are interpreted as content\");\n    }\n    state.documents.push(state.result);\n    if (state.position === state.lineStart && testDocumentSeparator(state)) {\n        if (state.input.charCodeAt(state.position) === 0x2E /* . */ ) {\n            state.position += 3;\n            skipSeparationSpace(state, true, -1);\n        }\n        return;\n    }\n    if (state.position < state.length - 1) {\n        throwError(state, \"end of the stream or a document separator is expected\");\n    } else {\n        return;\n    }\n}\nfunction loadDocuments(input, options) {\n    input = String(input);\n    options = options || {};\n    if (input.length !== 0) {\n        // Add tailing `\\n` if not exists\n        if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */  && input.charCodeAt(input.length - 1) !== 0x0D /* CR */ ) {\n            input += \"\\n\";\n        }\n        // Strip BOM\n        if (input.charCodeAt(0) === 0xFEFF) {\n            input = input.slice(1);\n        }\n    }\n    var state = new State$1(input, options);\n    var nullpos = input.indexOf(\"\\x00\");\n    if (nullpos !== -1) {\n        state.position = nullpos;\n        throwError(state, \"null byte is not allowed in input\");\n    }\n    // Use 0 as string terminator. That significantly simplifies bounds check.\n    state.input += \"\\x00\";\n    while(state.input.charCodeAt(state.position) === 0x20 /* Space */ ){\n        state.lineIndent += 1;\n        state.position += 1;\n    }\n    while(state.position < state.length - 1){\n        readDocument(state);\n    }\n    return state.documents;\n}\nfunction loadAll$1(input, iterator, options) {\n    if (iterator !== null && typeof iterator === \"object\" && typeof options === \"undefined\") {\n        options = iterator;\n        iterator = null;\n    }\n    var documents = loadDocuments(input, options);\n    if (typeof iterator !== \"function\") {\n        return documents;\n    }\n    for(var index = 0, length = documents.length; index < length; index += 1){\n        iterator(documents[index]);\n    }\n}\nfunction load$1(input, options) {\n    var documents = loadDocuments(input, options);\n    if (documents.length === 0) {\n        /*eslint-disable no-undefined*/ return undefined;\n    } else if (documents.length === 1) {\n        return documents[0];\n    }\n    throw new exception(\"expected a single document in the stream, but found more\");\n}\nvar loadAll_1 = loadAll$1;\nvar load_1 = load$1;\nvar loader = {\n    loadAll: loadAll_1,\n    load: load_1\n};\n/*eslint-disable no-use-before-define*/ var _toString = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar CHAR_BOM = 0xFEFF;\nvar CHAR_TAB = 0x09; /* Tab */ \nvar CHAR_LINE_FEED = 0x0A; /* LF */ \nvar CHAR_CARRIAGE_RETURN = 0x0D; /* CR */ \nvar CHAR_SPACE = 0x20; /* Space */ \nvar CHAR_EXCLAMATION = 0x21; /* ! */ \nvar CHAR_DOUBLE_QUOTE = 0x22; /* \" */ \nvar CHAR_SHARP = 0x23; /* # */ \nvar CHAR_PERCENT = 0x25; /* % */ \nvar CHAR_AMPERSAND = 0x26; /* & */ \nvar CHAR_SINGLE_QUOTE = 0x27; /* ' */ \nvar CHAR_ASTERISK = 0x2A; /* * */ \nvar CHAR_COMMA = 0x2C; /* , */ \nvar CHAR_MINUS = 0x2D; /* - */ \nvar CHAR_COLON = 0x3A; /* : */ \nvar CHAR_EQUALS = 0x3D; /* = */ \nvar CHAR_GREATER_THAN = 0x3E; /* > */ \nvar CHAR_QUESTION = 0x3F; /* ? */ \nvar CHAR_COMMERCIAL_AT = 0x40; /* @ */ \nvar CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */ \nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */ \nvar CHAR_GRAVE_ACCENT = 0x60; /* ` */ \nvar CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */ \nvar CHAR_VERTICAL_LINE = 0x7C; /* | */ \nvar CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */ \nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0x00] = \"\\\\0\";\nESCAPE_SEQUENCES[0x07] = \"\\\\a\";\nESCAPE_SEQUENCES[0x08] = \"\\\\b\";\nESCAPE_SEQUENCES[0x09] = \"\\\\t\";\nESCAPE_SEQUENCES[0x0A] = \"\\\\n\";\nESCAPE_SEQUENCES[0x0B] = \"\\\\v\";\nESCAPE_SEQUENCES[0x0C] = \"\\\\f\";\nESCAPE_SEQUENCES[0x0D] = \"\\\\r\";\nESCAPE_SEQUENCES[0x1B] = \"\\\\e\";\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\nESCAPE_SEQUENCES[0x5C] = \"\\\\\\\\\";\nESCAPE_SEQUENCES[0x85] = \"\\\\N\";\nESCAPE_SEQUENCES[0xA0] = \"\\\\_\";\nESCAPE_SEQUENCES[0x2028] = \"\\\\L\";\nESCAPE_SEQUENCES[0x2029] = \"\\\\P\";\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n    \"y\",\n    \"Y\",\n    \"yes\",\n    \"Yes\",\n    \"YES\",\n    \"on\",\n    \"On\",\n    \"ON\",\n    \"n\",\n    \"N\",\n    \"no\",\n    \"No\",\n    \"NO\",\n    \"off\",\n    \"Off\",\n    \"OFF\"\n];\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\nfunction compileStyleMap(schema, map) {\n    var result, keys, index, length, tag, style, type;\n    if (map === null) return {};\n    result = {};\n    keys = Object.keys(map);\n    for(index = 0, length = keys.length; index < length; index += 1){\n        tag = keys[index];\n        style = String(map[tag]);\n        if (tag.slice(0, 2) === \"!!\") {\n            tag = \"tag:yaml.org,2002:\" + tag.slice(2);\n        }\n        type = schema.compiledTypeMap[\"fallback\"][tag];\n        if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n            style = type.styleAliases[style];\n        }\n        result[tag] = style;\n    }\n    return result;\n}\nfunction encodeHex(character) {\n    var string, handle, length;\n    string = character.toString(16).toUpperCase();\n    if (character <= 0xFF) {\n        handle = \"x\";\n        length = 2;\n    } else if (character <= 0xFFFF) {\n        handle = \"u\";\n        length = 4;\n    } else if (character <= 0xFFFFFFFF) {\n        handle = \"U\";\n        length = 8;\n    } else {\n        throw new exception(\"code point within a string may not be greater than 0xFFFFFFFF\");\n    }\n    return \"\\\\\" + handle + common.repeat(\"0\", length - string.length) + string;\n}\nvar QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;\nfunction State(options) {\n    this.schema = options[\"schema\"] || _default;\n    this.indent = Math.max(1, options[\"indent\"] || 2);\n    this.noArrayIndent = options[\"noArrayIndent\"] || false;\n    this.skipInvalid = options[\"skipInvalid\"] || false;\n    this.flowLevel = common.isNothing(options[\"flowLevel\"]) ? -1 : options[\"flowLevel\"];\n    this.styleMap = compileStyleMap(this.schema, options[\"styles\"] || null);\n    this.sortKeys = options[\"sortKeys\"] || false;\n    this.lineWidth = options[\"lineWidth\"] || 80;\n    this.noRefs = options[\"noRefs\"] || false;\n    this.noCompatMode = options[\"noCompatMode\"] || false;\n    this.condenseFlow = options[\"condenseFlow\"] || false;\n    this.quotingType = options[\"quotingType\"] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n    this.forceQuotes = options[\"forceQuotes\"] || false;\n    this.replacer = typeof options[\"replacer\"] === \"function\" ? options[\"replacer\"] : null;\n    this.implicitTypes = this.schema.compiledImplicit;\n    this.explicitTypes = this.schema.compiledExplicit;\n    this.tag = null;\n    this.result = \"\";\n    this.duplicates = [];\n    this.usedDuplicates = null;\n}\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n    var ind = common.repeat(\" \", spaces), position = 0, next = -1, result = \"\", line, length = string.length;\n    while(position < length){\n        next = string.indexOf(\"\\n\", position);\n        if (next === -1) {\n            line = string.slice(position);\n            position = length;\n        } else {\n            line = string.slice(position, next + 1);\n            position = next + 1;\n        }\n        if (line.length && line !== \"\\n\") result += ind;\n        result += line;\n    }\n    return result;\n}\nfunction generateNextLine(state, level) {\n    return \"\\n\" + common.repeat(\" \", state.indent * level);\n}\nfunction testImplicitResolving(state, str) {\n    var index, length, type;\n    for(index = 0, length = state.implicitTypes.length; index < length; index += 1){\n        type = state.implicitTypes[index];\n        if (type.resolve(str)) {\n            return true;\n        }\n    }\n    return false;\n}\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n    return c === CHAR_SPACE || c === CHAR_TAB;\n}\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isnâ€™t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;\n}\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n}\n// [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out\n//                             c = flow-in   â‡’ ns-plain-safe-in\n//                             c = block-key â‡’ ns-plain-safe-out\n//                             c = flow-key  â‡’ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )\n//                            | ( /* An ns-char preceding */ â€œ#â€ )\n//                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n    return(// ns-plain-safe\n    (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP // false on '#'\n     && !(prev === CHAR_COLON && !cIsNsChar // false on ': '\n    ) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP // change to true on '[^ ]#'\n     || prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n    // Uses a subset of ns-char - c-indicator\n    // where ns-char = nb-char - s-white.\n    // No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part\n    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) // - s-white\n     && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n}\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n    // just not whitespace or colon, it will be checked to be plain character later\n    return !isWhitespace(c) && c !== CHAR_COLON;\n}\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n    var first = string.charCodeAt(pos), second;\n    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n        second = string.charCodeAt(pos + 1);\n        if (second >= 0xDC00 && second <= 0xDFFF) {\n            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n        }\n    }\n    return first;\n}\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n    var leadingSpaceRe = /^\\n* /;\n    return leadingSpaceRe.test(string);\n}\nvar STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {\n    var i;\n    var char = 0;\n    var prevChar = null;\n    var hasLineBreak = false;\n    var hasFoldableLine = false; // only checked if shouldTrackWidth\n    var shouldTrackWidth = lineWidth !== -1;\n    var previousLineBreak = -1; // count the first line correctly\n    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));\n    if (singleLineOnly || forceQuotes) {\n        // Case: no block styles.\n        // Check for disallowed characters to rule out plain and single.\n        for(i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){\n            char = codePointAt(string, i);\n            if (!isPrintable(char)) {\n                return STYLE_DOUBLE;\n            }\n            plain = plain && isPlainSafe(char, prevChar, inblock);\n            prevChar = char;\n        }\n    } else {\n        // Case: block styles permitted.\n        for(i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){\n            char = codePointAt(string, i);\n            if (char === CHAR_LINE_FEED) {\n                hasLineBreak = true;\n                // Check if any line can be folded.\n                if (shouldTrackWidth) {\n                    hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n                    i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== \" \";\n                    previousLineBreak = i;\n                }\n            } else if (!isPrintable(char)) {\n                return STYLE_DOUBLE;\n            }\n            plain = plain && isPlainSafe(char, prevChar, inblock);\n            prevChar = char;\n        }\n        // in case the end is missing a \\n\n        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== \" \";\n    }\n    // Although every style can represent \\n without escaping, prefer block styles\n    // for multiline, since they're more readable and they don't add empty lines.\n    // Also prefer folding a super-long line.\n    if (!hasLineBreak && !hasFoldableLine) {\n        // Strings interpretable as another type have to be quoted;\n        // e.g. the string 'true' vs. the boolean true.\n        if (plain && !forceQuotes && !testAmbiguousType(string)) {\n            return STYLE_PLAIN;\n        }\n        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n    }\n    // Edge case: block indentation indicator can only have one digit.\n    if (indentPerLevel > 9 && needIndentIndicator(string)) {\n        return STYLE_DOUBLE;\n    }\n    // At this point we know block styles are valid.\n    // Prefer literal style unless we want to fold.\n    if (!forceQuotes) {\n        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    â€¢ No ending newline => unaffected; already using strip \"-\" chomping.\n//    â€¢ Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n    state.dump = function() {\n        if (string.length === 0) {\n            return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n        }\n        if (!state.noCompatMode) {\n            if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n                return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"' + string + '\"' : \"'\" + string + \"'\";\n            }\n        }\n        var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n        // As indentation gets deeper, let the width decrease monotonically\n        // to the lower bound min(state.lineWidth, 40).\n        // Note that this implies\n        //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.\n        //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n        // This behaves better than a constant minimum width which disallows narrower options,\n        // or an indent threshold which causes the width to suddenly increase.\n        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n        // Without knowing if keys are implicit/explicit, assume implicit for safety.\n        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;\n        function testAmbiguity(string) {\n            return testImplicitResolving(state, string);\n        }\n        switch(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)){\n            case STYLE_PLAIN:\n                return string;\n            case STYLE_SINGLE:\n                return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n            case STYLE_LITERAL:\n                return \"|\" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n            case STYLE_FOLDED:\n                return \">\" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n            case STYLE_DOUBLE:\n                return '\"' + escapeString(string) + '\"';\n            default:\n                throw new exception(\"impossible error: invalid scalar style\");\n        }\n    }();\n}\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : \"\";\n    // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n    var clip = string[string.length - 1] === \"\\n\";\n    var keep = clip && (string[string.length - 2] === \"\\n\" || string === \"\\n\");\n    var chomp = keep ? \"+\" : clip ? \"\" : \"-\";\n    return indentIndicator + chomp + \"\\n\";\n}\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n    return string[string.length - 1] === \"\\n\" ? string.slice(0, -1) : string;\n}\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n    // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”\n    // unless they're before or after a more-indented line, or at the very\n    // beginning or end, in which case $k$ maps to $k$.\n    // Therefore, parse each chunk as newline(s) followed by a content line.\n    var lineRe = /(\\n+)([^\\n]*)/g;\n    // first line (possibly an empty line)\n    var result = function() {\n        var nextLF = string.indexOf(\"\\n\");\n        nextLF = nextLF !== -1 ? nextLF : string.length;\n        lineRe.lastIndex = nextLF;\n        return foldLine(string.slice(0, nextLF), width);\n    }();\n    // If we haven't reached the first content line yet, don't add an extra \\n.\n    var prevMoreIndented = string[0] === \"\\n\" || string[0] === \" \";\n    var moreIndented;\n    // rest of the lines\n    var match;\n    while(match = lineRe.exec(string)){\n        var prefix = match[1], line = match[2];\n        moreIndented = line[0] === \" \";\n        result += prefix + (!prevMoreIndented && !moreIndented && line !== \"\" ? \"\\n\" : \"\") + foldLine(line, width);\n        prevMoreIndented = moreIndented;\n    }\n    return result;\n}\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n    if (line === \"\" || line[0] === \" \") return line;\n    // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n    var match;\n    // start is an inclusive index. end, curr, and next are exclusive.\n    var start = 0, end, curr = 0, next = 0;\n    var result = \"\";\n    // Invariants: 0 <= start <= length-1.\n    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n    // Inside the loop:\n    //   A match implies length >= 2, so curr and next are <= length-2.\n    while(match = breakRe.exec(line)){\n        next = match.index;\n        // maintain invariant: curr - start <= width\n        if (next - start > width) {\n            end = curr > start ? curr : next; // derive end <= length-2\n            result += \"\\n\" + line.slice(start, end);\n            // skip the space that was output as \\n\n            start = end + 1; // derive start <= length-1\n        }\n        curr = next;\n    }\n    // By the invariants, start <= length-1, so there is something left over.\n    // It is either the whole string or a part starting from non-whitespace.\n    result += \"\\n\";\n    // Insert a break if the remainder is too long and there is a break available.\n    if (line.length - start > width && curr > start) {\n        result += line.slice(start, curr) + \"\\n\" + line.slice(curr + 1);\n    } else {\n        result += line.slice(start);\n    }\n    return result.slice(1); // drop extra \\n joiner\n}\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n    var result = \"\";\n    var char = 0;\n    var escapeSeq;\n    for(var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){\n        char = codePointAt(string, i);\n        escapeSeq = ESCAPE_SEQUENCES[char];\n        if (!escapeSeq && isPrintable(char)) {\n            result += string[i];\n            if (char >= 0x10000) result += string[i + 1];\n        } else {\n            result += escapeSeq || encodeHex(char);\n        }\n    }\n    return result;\n}\nfunction writeFlowSequence(state, level, object) {\n    var _result = \"\", _tag = state.tag, index, length, value;\n    for(index = 0, length = object.length; index < length; index += 1){\n        value = object[index];\n        if (state.replacer) {\n            value = state.replacer.call(object, String(index), value);\n        }\n        // Write only valid elements, put null instead of invalid elements.\n        if (writeNode(state, level, value, false, false) || typeof value === \"undefined\" && writeNode(state, level, null, false, false)) {\n            if (_result !== \"\") _result += \",\" + (!state.condenseFlow ? \" \" : \"\");\n            _result += state.dump;\n        }\n    }\n    state.tag = _tag;\n    state.dump = \"[\" + _result + \"]\";\n}\nfunction writeBlockSequence(state, level, object, compact) {\n    var _result = \"\", _tag = state.tag, index, length, value;\n    for(index = 0, length = object.length; index < length; index += 1){\n        value = object[index];\n        if (state.replacer) {\n            value = state.replacer.call(object, String(index), value);\n        }\n        // Write only valid elements, put null instead of invalid elements.\n        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === \"undefined\" && writeNode(state, level + 1, null, true, true, false, true)) {\n            if (!compact || _result !== \"\") {\n                _result += generateNextLine(state, level);\n            }\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n                _result += \"-\";\n            } else {\n                _result += \"- \";\n            }\n            _result += state.dump;\n        }\n    }\n    state.tag = _tag;\n    state.dump = _result || \"[]\"; // Empty sequence if no valid values.\n}\nfunction writeFlowMapping(state, level, object) {\n    var _result = \"\", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;\n    for(index = 0, length = objectKeyList.length; index < length; index += 1){\n        pairBuffer = \"\";\n        if (_result !== \"\") pairBuffer += \", \";\n        if (state.condenseFlow) pairBuffer += '\"';\n        objectKey = objectKeyList[index];\n        objectValue = object[objectKey];\n        if (state.replacer) {\n            objectValue = state.replacer.call(object, objectKey, objectValue);\n        }\n        if (!writeNode(state, level, objectKey, false, false)) {\n            continue; // Skip this pair because of invalid key;\n        }\n        if (state.dump.length > 1024) pairBuffer += \"? \";\n        pairBuffer += state.dump + (state.condenseFlow ? '\"' : \"\") + \":\" + (state.condenseFlow ? \"\" : \" \");\n        if (!writeNode(state, level, objectValue, false, false)) {\n            continue; // Skip this pair because of invalid value.\n        }\n        pairBuffer += state.dump;\n        // Both key and value are valid.\n        _result += pairBuffer;\n    }\n    state.tag = _tag;\n    state.dump = \"{\" + _result + \"}\";\n}\nfunction writeBlockMapping(state, level, object, compact) {\n    var _result = \"\", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;\n    // Allow sorting keys so that the output file is deterministic\n    if (state.sortKeys === true) {\n        // Default sorting\n        objectKeyList.sort();\n    } else if (typeof state.sortKeys === \"function\") {\n        // Custom sort function\n        objectKeyList.sort(state.sortKeys);\n    } else if (state.sortKeys) {\n        // Something is wrong\n        throw new exception(\"sortKeys must be a boolean or a function\");\n    }\n    for(index = 0, length = objectKeyList.length; index < length; index += 1){\n        pairBuffer = \"\";\n        if (!compact || _result !== \"\") {\n            pairBuffer += generateNextLine(state, level);\n        }\n        objectKey = objectKeyList[index];\n        objectValue = object[objectKey];\n        if (state.replacer) {\n            objectValue = state.replacer.call(object, objectKey, objectValue);\n        }\n        if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n            continue; // Skip this pair because of invalid key.\n        }\n        explicitPair = state.tag !== null && state.tag !== \"?\" || state.dump && state.dump.length > 1024;\n        if (explicitPair) {\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n                pairBuffer += \"?\";\n            } else {\n                pairBuffer += \"? \";\n            }\n        }\n        pairBuffer += state.dump;\n        if (explicitPair) {\n            pairBuffer += generateNextLine(state, level);\n        }\n        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n            continue; // Skip this pair because of invalid value.\n        }\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n            pairBuffer += \":\";\n        } else {\n            pairBuffer += \": \";\n        }\n        pairBuffer += state.dump;\n        // Both key and value are valid.\n        _result += pairBuffer;\n    }\n    state.tag = _tag;\n    state.dump = _result || \"{}\"; // Empty mapping if no valid pairs.\n}\nfunction detectType(state, object, explicit) {\n    var _result, typeList, index, length, type, style;\n    typeList = explicit ? state.explicitTypes : state.implicitTypes;\n    for(index = 0, length = typeList.length; index < length; index += 1){\n        type = typeList[index];\n        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === \"object\" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n            if (explicit) {\n                if (type.multi && type.representName) {\n                    state.tag = type.representName(object);\n                } else {\n                    state.tag = type.tag;\n                }\n            } else {\n                state.tag = \"?\";\n            }\n            if (type.represent) {\n                style = state.styleMap[type.tag] || type.defaultStyle;\n                if (_toString.call(type.represent) === \"[object Function]\") {\n                    _result = type.represent(object, style);\n                } else if (_hasOwnProperty.call(type.represent, style)) {\n                    _result = type.represent[style](object, style);\n                } else {\n                    throw new exception(\"!<\" + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n                }\n                state.dump = _result;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n    state.tag = null;\n    state.dump = object;\n    if (!detectType(state, object, false)) {\n        detectType(state, object, true);\n    }\n    var type = _toString.call(state.dump);\n    var inblock = block;\n    var tagStr;\n    if (block) {\n        block = state.flowLevel < 0 || state.flowLevel > level;\n    }\n    var objectOrArray = type === \"[object Object]\" || type === \"[object Array]\", duplicateIndex, duplicate;\n    if (objectOrArray) {\n        duplicateIndex = state.duplicates.indexOf(object);\n        duplicate = duplicateIndex !== -1;\n    }\n    if (state.tag !== null && state.tag !== \"?\" || duplicate || state.indent !== 2 && level > 0) {\n        compact = false;\n    }\n    if (duplicate && state.usedDuplicates[duplicateIndex]) {\n        state.dump = \"*ref_\" + duplicateIndex;\n    } else {\n        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n            state.usedDuplicates[duplicateIndex] = true;\n        }\n        if (type === \"[object Object]\") {\n            if (block && Object.keys(state.dump).length !== 0) {\n                writeBlockMapping(state, level, state.dump, compact);\n                if (duplicate) {\n                    state.dump = \"&ref_\" + duplicateIndex + state.dump;\n                }\n            } else {\n                writeFlowMapping(state, level, state.dump);\n                if (duplicate) {\n                    state.dump = \"&ref_\" + duplicateIndex + \" \" + state.dump;\n                }\n            }\n        } else if (type === \"[object Array]\") {\n            if (block && state.dump.length !== 0) {\n                if (state.noArrayIndent && !isblockseq && level > 0) {\n                    writeBlockSequence(state, level - 1, state.dump, compact);\n                } else {\n                    writeBlockSequence(state, level, state.dump, compact);\n                }\n                if (duplicate) {\n                    state.dump = \"&ref_\" + duplicateIndex + state.dump;\n                }\n            } else {\n                writeFlowSequence(state, level, state.dump);\n                if (duplicate) {\n                    state.dump = \"&ref_\" + duplicateIndex + \" \" + state.dump;\n                }\n            }\n        } else if (type === \"[object String]\") {\n            if (state.tag !== \"?\") {\n                writeScalar(state, state.dump, level, iskey, inblock);\n            }\n        } else if (type === \"[object Undefined]\") {\n            return false;\n        } else {\n            if (state.skipInvalid) return false;\n            throw new exception(\"unacceptable kind of an object to dump \" + type);\n        }\n        if (state.tag !== null && state.tag !== \"?\") {\n            // Need to encode all characters except those allowed by the spec:\n            //\n            // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n            // [36] ns-hex-digit    ::=  ns-dec-digit\n            //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n            // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n            // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€\n            // [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€\n            //                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€\n            //                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ'â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€\n            //\n            // Also need to encode '!' because it has special meaning (end of tag prefix).\n            //\n            tagStr = encodeURI(state.tag[0] === \"!\" ? state.tag.slice(1) : state.tag).replace(/!/g, \"%21\");\n            if (state.tag[0] === \"!\") {\n                tagStr = \"!\" + tagStr;\n            } else if (tagStr.slice(0, 18) === \"tag:yaml.org,2002:\") {\n                tagStr = \"!!\" + tagStr.slice(18);\n            } else {\n                tagStr = \"!<\" + tagStr + \">\";\n            }\n            state.dump = tagStr + \" \" + state.dump;\n        }\n    }\n    return true;\n}\nfunction getDuplicateReferences(object, state) {\n    var objects = [], duplicatesIndexes = [], index, length;\n    inspectNode(object, objects, duplicatesIndexes);\n    for(index = 0, length = duplicatesIndexes.length; index < length; index += 1){\n        state.duplicates.push(objects[duplicatesIndexes[index]]);\n    }\n    state.usedDuplicates = new Array(length);\n}\nfunction inspectNode(object, objects, duplicatesIndexes) {\n    var objectKeyList, index, length;\n    if (object !== null && typeof object === \"object\") {\n        index = objects.indexOf(object);\n        if (index !== -1) {\n            if (duplicatesIndexes.indexOf(index) === -1) {\n                duplicatesIndexes.push(index);\n            }\n        } else {\n            objects.push(object);\n            if (Array.isArray(object)) {\n                for(index = 0, length = object.length; index < length; index += 1){\n                    inspectNode(object[index], objects, duplicatesIndexes);\n                }\n            } else {\n                objectKeyList = Object.keys(object);\n                for(index = 0, length = objectKeyList.length; index < length; index += 1){\n                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n                }\n            }\n        }\n    }\n}\nfunction dump$1(input, options) {\n    options = options || {};\n    var state = new State(options);\n    if (!state.noRefs) getDuplicateReferences(input, state);\n    var value = input;\n    if (state.replacer) {\n        value = state.replacer.call({\n            \"\": value\n        }, \"\", value);\n    }\n    if (writeNode(state, 0, value, true, true)) return state.dump + \"\\n\";\n    return \"\";\n}\nvar dump_1 = dump$1;\nvar dumper = {\n    dump: dump_1\n};\nfunction renamed(from, to) {\n    return function() {\n        throw new Error(\"Function yaml.\" + from + \" is removed in js-yaml 4. \" + \"Use yaml.\" + to + \" instead, which is now safe by default.\");\n    };\n}\nvar Type = type;\nvar Schema = schema;\nvar FAILSAFE_SCHEMA = failsafe;\nvar JSON_SCHEMA = json;\nvar CORE_SCHEMA = core;\nvar DEFAULT_SCHEMA = _default;\nvar load = loader.load;\nvar loadAll = loader.loadAll;\nvar dump = dumper.dump;\nvar YAMLException = exception;\n// Re-export all types in case user wants to create custom schema\nvar types = {\n    binary: binary,\n    float: float,\n    map: map,\n    null: _null,\n    pairs: pairs,\n    set: set,\n    timestamp: timestamp,\n    bool: bool,\n    int: int,\n    merge: merge,\n    omap: omap,\n    seq: seq,\n    str: str\n};\n// Removed functions from JS-YAML 3.0.x\nvar safeLoad = renamed(\"safeLoad\", \"load\");\nvar safeLoadAll = renamed(\"safeLoadAll\", \"loadAll\");\nvar safeDump = renamed(\"safeDump\", \"dump\");\nvar jsYaml = {\n    Type: Type,\n    Schema: Schema,\n    FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n    JSON_SCHEMA: JSON_SCHEMA,\n    CORE_SCHEMA: CORE_SCHEMA,\n    DEFAULT_SCHEMA: DEFAULT_SCHEMA,\n    load: load,\n    loadAll: loadAll,\n    dump: dump,\n    YAMLException: YAMLException,\n    types: types,\n    safeLoad: safeLoad,\n    safeLoadAll: safeLoadAll,\n    safeDump: safeDump\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanMteWFtbC9kaXN0L2pzLXlhbWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLGlFQUFpRSxHQUNqRSxTQUFTQSxVQUFVQyxPQUFPO0lBQ3hCLE9BQU8sT0FBUUEsWUFBWSxlQUFpQkEsWUFBWTtBQUMxRDtBQUdBLFNBQVNDLFNBQVNELE9BQU87SUFDdkIsT0FBTyxPQUFRQSxZQUFZLFlBQWNBLFlBQVk7QUFDdkQ7QUFHQSxTQUFTRSxRQUFRQyxRQUFRO0lBQ3ZCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsV0FBVyxPQUFPQTtTQUMvQixJQUFJSixVQUFVSSxXQUFXLE9BQU8sRUFBRTtJQUV2QyxPQUFPO1FBQUVBO0tBQVU7QUFDckI7QUFHQSxTQUFTRyxPQUFPQyxNQUFNLEVBQUVDLE1BQU07SUFDNUIsSUFBSUMsT0FBT0MsUUFBUUMsS0FBS0M7SUFFeEIsSUFBSUosUUFBUTtRQUNWSSxhQUFhQyxPQUFPQyxJQUFJLENBQUNOO1FBRXpCLElBQUtDLFFBQVEsR0FBR0MsU0FBU0UsV0FBV0YsTUFBTSxFQUFFRCxRQUFRQyxRQUFRRCxTQUFTLEVBQUc7WUFDdEVFLE1BQU1DLFVBQVUsQ0FBQ0gsTUFBTTtZQUN2QkYsTUFBTSxDQUFDSSxJQUFJLEdBQUdILE1BQU0sQ0FBQ0csSUFBSTtRQUMzQjtJQUNGO0lBRUEsT0FBT0o7QUFDVDtBQUdBLFNBQVNRLE9BQU9DLE1BQU0sRUFBRUMsS0FBSztJQUMzQixJQUFJQyxTQUFTLElBQUlDO0lBRWpCLElBQUtBLFFBQVEsR0FBR0EsUUFBUUYsT0FBT0UsU0FBUyxFQUFHO1FBQ3pDRCxVQUFVRjtJQUNaO0lBRUEsT0FBT0U7QUFDVDtBQUdBLFNBQVNFLGVBQWVDLE1BQU07SUFDNUIsT0FBTyxXQUFZLEtBQU9DLE9BQU9DLGlCQUFpQixLQUFLLElBQUlGO0FBQzdEO0FBR0EsSUFBSUcsY0FBbUJ6QjtBQUN2QixJQUFJMEIsYUFBbUJ4QjtBQUN2QixJQUFJeUIsWUFB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T0FBT0UsSUFBSTtBQUNyQyxJQUFJRCxVQUFzQkQsT0FBT0MsT0FBTztBQUN4QyxJQUFJNEYsT0FBc0I2QyxPQUFPN0MsSUFBSTtBQUNyQyxJQUFJdUQsZ0JBQXNCeGdCO0FBRTFCLGlFQUFpRTtBQUNqRSxJQUFJeWdCLFFBQVE7SUFDVjFZLFFBQVdBO0lBQ1hvQixPQUFXQTtJQUNYNUYsS0FBV0E7SUFDWG1kLE1BQVduYTtJQUNYaUcsT0FBV0E7SUFDWEksS0FBV0E7SUFDWGpDLFdBQVdBO0lBQ1gzRCxNQUFXQTtJQUNYYyxLQUFXQTtJQUNYK0MsT0FBV0E7SUFDWHVCLE1BQVdBO0lBQ1huRyxLQUFXQTtJQUNYbkUsS0FBV0E7QUFDYjtBQUVBLHVDQUF1QztBQUN2QyxJQUFJNmUsV0FBc0JaLFFBQVEsWUFBWTtBQUM5QyxJQUFJYSxjQUFzQmIsUUFBUSxlQUFlO0FBQ2pELElBQUljLFdBQXNCZCxRQUFRLFlBQVk7QUFFOUMsSUFBSWUsU0FBUztJQUNaWixNQUFNQTtJQUNOQyxRQUFRQTtJQUNSQyxpQkFBaUJBO0lBQ2pCQyxhQUFhQTtJQUNiQyxhQUFhQTtJQUNiQyxnQkFBZ0JBO0lBQ2hCakosTUFBTUE7SUFDTkQsU0FBU0E7SUFDVDRGLE1BQU1BO0lBQ051RCxlQUFlQTtJQUNmQyxPQUFPQTtJQUNQRSxVQUFVQTtJQUNWQyxhQUFhQTtJQUNiQyxVQUFVQTtBQUNYO0FBRWtMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFjbWlsbGFuLWtlY2std2ViLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvZGlzdC9qcy15YW1sLm1qcz83Yzc1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohIGpzLXlhbWwgNC4xLjEgaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9qcy15YW1sIEBsaWNlbnNlIE1JVCAqL1xuZnVuY3Rpb24gaXNOb3RoaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHx8IChzdWJqZWN0ID09PSBudWxsKTtcbn1cblxuXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnKSAmJiAoc3ViamVjdCAhPT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gdG9BcnJheShzZXF1ZW5jZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHJldHVybiBzZXF1ZW5jZTtcbiAgZWxzZSBpZiAoaXNOb3RoaW5nKHNlcXVlbmNlKSkgcmV0dXJuIFtdO1xuXG4gIHJldHVybiBbIHNlcXVlbmNlIF07XG59XG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCBrZXksIHNvdXJjZUtleXM7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgY291bnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBjeWNsZTtcblxuICBmb3IgKGN5Y2xlID0gMDsgY3ljbGUgPCBjb3VudDsgY3ljbGUgKz0gMSkge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzTmVnYXRpdmVaZXJvKG51bWJlcikge1xuICByZXR1cm4gKG51bWJlciA9PT0gMCkgJiYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gMSAvIG51bWJlcik7XG59XG5cblxudmFyIGlzTm90aGluZ18xICAgICAgPSBpc05vdGhpbmc7XG52YXIgaXNPYmplY3RfMSAgICAgICA9IGlzT2JqZWN0O1xudmFyIHRvQXJyYXlfMSAgICAgICAgPSB0b0FycmF5O1xudmFyIHJlcGVhdF8xICAgICAgICAgPSByZXBlYXQ7XG52YXIgaXNOZWdhdGl2ZVplcm9fMSA9IGlzTmVnYXRpdmVaZXJvO1xudmFyIGV4dGVuZF8xICAgICAgICAgPSBleHRlbmQ7XG5cbnZhciBjb21tb24gPSB7XG5cdGlzTm90aGluZzogaXNOb3RoaW5nXzEsXG5cdGlzT2JqZWN0OiBpc09iamVjdF8xLFxuXHR0b0FycmF5OiB0b0FycmF5XzEsXG5cdHJlcGVhdDogcmVwZWF0XzEsXG5cdGlzTmVnYXRpdmVaZXJvOiBpc05lZ2F0aXZlWmVyb18xLFxuXHRleHRlbmQ6IGV4dGVuZF8xXG59O1xuXG4vLyBZQU1MIGVycm9yIGNsYXNzLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTg5ODRcblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcihleGNlcHRpb24sIGNvbXBhY3QpIHtcbiAgdmFyIHdoZXJlID0gJycsIG1lc3NhZ2UgPSBleGNlcHRpb24ucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJztcblxuICBpZiAoIWV4Y2VwdGlvbi5tYXJrKSByZXR1cm4gbWVzc2FnZTtcblxuICBpZiAoZXhjZXB0aW9uLm1hcmsubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyBleGNlcHRpb24ubWFyay5uYW1lICsgJ1wiICc7XG4gIH1cblxuICB3aGVyZSArPSAnKCcgKyAoZXhjZXB0aW9uLm1hcmsubGluZSArIDEpICsgJzonICsgKGV4Y2VwdGlvbi5tYXJrLmNvbHVtbiArIDEpICsgJyknO1xuXG4gIGlmICghY29tcGFjdCAmJiBleGNlcHRpb24ubWFyay5zbmlwcGV0KSB7XG4gICAgd2hlcmUgKz0gJ1xcblxcbicgKyBleGNlcHRpb24ubWFyay5zbmlwcGV0O1xuICB9XG5cbiAgcmV0dXJuIG1lc3NhZ2UgKyAnICcgKyB3aGVyZTtcbn1cblxuXG5mdW5jdGlvbiBZQU1MRXhjZXB0aW9uJDEocmVhc29uLCBtYXJrKSB7XG4gIC8vIFN1cGVyIGNvbnN0cnVjdG9yXG4gIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5uYW1lID0gJ1lBTUxFeGNlcHRpb24nO1xuICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgdGhpcy5tYXJrID0gbWFyaztcbiAgdGhpcy5tZXNzYWdlID0gZm9ybWF0RXJyb3IodGhpcywgZmFsc2UpO1xuXG4gIC8vIEluY2x1ZGUgc3RhY2sgdHJhY2UgaW4gZXJyb3Igb2JqZWN0XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIC8vIENocm9tZSBhbmQgTm9kZUpTXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gRkYsIElFIDEwKyBhbmQgU2FmYXJpIDYrLiBGYWxsYmFjayBmb3Igb3RoZXJzXG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2sgfHwgJyc7XG4gIH1cbn1cblxuXG4vLyBJbmhlcml0IGZyb20gRXJyb3JcbllBTUxFeGNlcHRpb24kMS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5ZQU1MRXhjZXB0aW9uJDEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWUFNTEV4Y2VwdGlvbiQxO1xuXG5cbllBTUxFeGNlcHRpb24kMS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHJldHVybiB0aGlzLm5hbWUgKyAnOiAnICsgZm9ybWF0RXJyb3IodGhpcywgY29tcGFjdCk7XG59O1xuXG5cbnZhciBleGNlcHRpb24gPSBZQU1MRXhjZXB0aW9uJDE7XG5cbi8vIGdldCBzbmlwcGV0IGZvciBhIHNpbmdsZSBsaW5lLCByZXNwZWN0aW5nIG1heExlbmd0aFxuZnVuY3Rpb24gZ2V0TGluZShidWZmZXIsIGxpbmVTdGFydCwgbGluZUVuZCwgcG9zaXRpb24sIG1heExpbmVMZW5ndGgpIHtcbiAgdmFyIGhlYWQgPSAnJztcbiAgdmFyIHRhaWwgPSAnJztcbiAgdmFyIG1heEhhbGZMZW5ndGggPSBNYXRoLmZsb29yKG1heExpbmVMZW5ndGggLyAyKSAtIDE7XG5cbiAgaWYgKHBvc2l0aW9uIC0gbGluZVN0YXJ0ID4gbWF4SGFsZkxlbmd0aCkge1xuICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgIGxpbmVTdGFydCA9IHBvc2l0aW9uIC0gbWF4SGFsZkxlbmd0aCArIGhlYWQubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGxpbmVFbmQgLSBwb3NpdGlvbiA+IG1heEhhbGZMZW5ndGgpIHtcbiAgICB0YWlsID0gJyAuLi4nO1xuICAgIGxpbmVFbmQgPSBwb3NpdGlvbiArIG1heEhhbGZMZW5ndGggLSB0YWlsLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RyOiBoZWFkICsgYnVmZmVyLnNsaWNlKGxpbmVTdGFydCwgbGluZUVuZCkucmVwbGFjZSgvXFx0L2csICfihpInKSArIHRhaWwsXG4gICAgcG9zOiBwb3NpdGlvbiAtIGxpbmVTdGFydCArIGhlYWQubGVuZ3RoIC8vIHJlbGF0aXZlIHBvc2l0aW9uXG4gIH07XG59XG5cblxuZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCBtYXgpIHtcbiAgcmV0dXJuIGNvbW1vbi5yZXBlYXQoJyAnLCBtYXggLSBzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn1cblxuXG5mdW5jdGlvbiBtYWtlU25pcHBldChtYXJrLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgbnVsbCk7XG5cbiAgaWYgKCFtYXJrLmJ1ZmZlcikgcmV0dXJuIG51bGw7XG5cbiAgaWYgKCFvcHRpb25zLm1heExlbmd0aCkgb3B0aW9ucy5tYXhMZW5ndGggPSA3OTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluZGVudCAgICAgICE9PSAnbnVtYmVyJykgb3B0aW9ucy5pbmRlbnQgICAgICA9IDE7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5saW5lc0JlZm9yZSAhPT0gJ251bWJlcicpIG9wdGlvbnMubGluZXNCZWZvcmUgPSAzO1xuICBpZiAodHlwZW9mIG9wdGlvbnMubGluZXNBZnRlciAgIT09ICdudW1iZXInKSBvcHRpb25zLmxpbmVzQWZ0ZXIgID0gMjtcblxuICB2YXIgcmUgPSAvXFxyP1xcbnxcXHJ8XFwwL2c7XG4gIHZhciBsaW5lU3RhcnRzID0gWyAwIF07XG4gIHZhciBsaW5lRW5kcyA9IFtdO1xuICB2YXIgbWF0Y2g7XG4gIHZhciBmb3VuZExpbmVObyA9IC0xO1xuXG4gIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKG1hcmsuYnVmZmVyKSkpIHtcbiAgICBsaW5lRW5kcy5wdXNoKG1hdGNoLmluZGV4KTtcbiAgICBsaW5lU3RhcnRzLnB1c2gobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuXG4gICAgaWYgKG1hcmsucG9zaXRpb24gPD0gbWF0Y2guaW5kZXggJiYgZm91bmRMaW5lTm8gPCAwKSB7XG4gICAgICBmb3VuZExpbmVObyA9IGxpbmVTdGFydHMubGVuZ3RoIC0gMjtcbiAgICB9XG4gIH1cblxuICBpZiAoZm91bmRMaW5lTm8gPCAwKSBmb3VuZExpbmVObyA9IGxpbmVTdGFydHMubGVuZ3RoIC0gMTtcblxuICB2YXIgcmVzdWx0ID0gJycsIGksIGxpbmU7XG4gIHZhciBsaW5lTm9MZW5ndGggPSBNYXRoLm1pbihtYXJrLmxpbmUgKyBvcHRpb25zLmxpbmVzQWZ0ZXIsIGxpbmVFbmRzLmxlbmd0aCkudG9TdHJpbmcoKS5sZW5ndGg7XG4gIHZhciBtYXhMaW5lTGVuZ3RoID0gb3B0aW9ucy5tYXhMZW5ndGggLSAob3B0aW9ucy5pbmRlbnQgKyBsaW5lTm9MZW5ndGggKyAzKTtcblxuICBmb3IgKGkgPSAxOyBpIDw9IG9wdGlvbnMubGluZXNCZWZvcmU7IGkrKykge1xuICAgIGlmIChmb3VuZExpbmVObyAtIGkgPCAwKSBicmVhaztcbiAgICBsaW5lID0gZ2V0TGluZShcbiAgICAgIG1hcmsuYnVmZmVyLFxuICAgICAgbGluZVN0YXJ0c1tmb3VuZExpbmVObyAtIGldLFxuICAgICAgbGluZUVuZHNbZm91bmRMaW5lTm8gLSBpXSxcbiAgICAgIG1hcmsucG9zaXRpb24gLSAobGluZVN0YXJ0c1tmb3VuZExpbmVOb10gLSBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vIC0gaV0pLFxuICAgICAgbWF4TGluZUxlbmd0aFxuICAgICk7XG4gICAgcmVzdWx0ID0gY29tbW9uLnJlcGVhdCgnICcsIG9wdGlvbnMuaW5kZW50KSArIHBhZFN0YXJ0KChtYXJrLmxpbmUgLSBpICsgMSkudG9TdHJpbmcoKSwgbGluZU5vTGVuZ3RoKSArXG4gICAgICAnIHwgJyArIGxpbmUuc3RyICsgJ1xcbicgKyByZXN1bHQ7XG4gIH1cblxuICBsaW5lID0gZ2V0TGluZShtYXJrLmJ1ZmZlciwgbGluZVN0YXJ0c1tmb3VuZExpbmVOb10sIGxpbmVFbmRzW2ZvdW5kTGluZU5vXSwgbWFyay5wb3NpdGlvbiwgbWF4TGluZUxlbmd0aCk7XG4gIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSArIDEpLnRvU3RyaW5nKCksIGxpbmVOb0xlbmd0aCkgK1xuICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJztcbiAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJy0nLCBvcHRpb25zLmluZGVudCArIGxpbmVOb0xlbmd0aCArIDMgKyBsaW5lLnBvcykgKyAnXicgKyAnXFxuJztcblxuICBmb3IgKGkgPSAxOyBpIDw9IG9wdGlvbnMubGluZXNBZnRlcjsgaSsrKSB7XG4gICAgaWYgKGZvdW5kTGluZU5vICsgaSA+PSBsaW5lRW5kcy5sZW5ndGgpIGJyZWFrO1xuICAgIGxpbmUgPSBnZXRMaW5lKFxuICAgICAgbWFyay5idWZmZXIsXG4gICAgICBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vICsgaV0sXG4gICAgICBsaW5lRW5kc1tmb3VuZExpbmVObyArIGldLFxuICAgICAgbWFyay5wb3NpdGlvbiAtIChsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSAtIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gKyBpXSksXG4gICAgICBtYXhMaW5lTGVuZ3RoXG4gICAgKTtcbiAgICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnICcsIG9wdGlvbnMuaW5kZW50KSArIHBhZFN0YXJ0KChtYXJrLmxpbmUgKyBpICsgMSkudG9TdHJpbmcoKSwgbGluZU5vTGVuZ3RoKSArXG4gICAgICAnIHwgJyArIGxpbmUuc3RyICsgJ1xcbic7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1xcbiQvLCAnJyk7XG59XG5cblxudmFyIHNuaXBwZXQgPSBtYWtlU25pcHBldDtcblxudmFyIFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUyA9IFtcbiAgJ2tpbmQnLFxuICAnbXVsdGknLFxuICAncmVzb2x2ZScsXG4gICdjb25zdHJ1Y3QnLFxuICAnaW5zdGFuY2VPZicsXG4gICdwcmVkaWNhdGUnLFxuICAncmVwcmVzZW50JyxcbiAgJ3JlcHJlc2VudE5hbWUnLFxuICAnZGVmYXVsdFN0eWxlJyxcbiAgJ3N0eWxlQWxpYXNlcydcbl07XG5cbnZhciBZQU1MX05PREVfS0lORFMgPSBbXG4gICdzY2FsYXInLFxuICAnc2VxdWVuY2UnLFxuICAnbWFwcGluZydcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZUFsaWFzZXMobWFwKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgbWFwW3N0eWxlXS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXN1bHRbU3RyaW5nKGFsaWFzKV0gPSBzdHlsZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gVHlwZSQxKHRhZywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignVW5rbm93biBvcHRpb24gXCInICsgbmFtZSArICdcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVE9ETzogQWRkIHRhZyBmb3JtYXQgY2hlY2suXG4gIHRoaXMub3B0aW9ucyAgICAgICA9IG9wdGlvbnM7IC8vIGtlZXAgb3JpZ2luYWwgb3B0aW9ucyBpbiBjYXNlIHVzZXIgd2FudHMgdG8gZXh0ZW5kIHRoaXMgdHlwZSBsYXRlclxuICB0aGlzLnRhZyAgICAgICAgICAgPSB0YWc7XG4gIHRoaXMua2luZCAgICAgICAgICA9IG9wdGlvbnNbJ2tpbmQnXSAgICAgICAgICB8fCBudWxsO1xuICB0aGlzLnJlc29sdmUgICAgICAgPSBvcHRpb25zWydyZXNvbHZlJ10gICAgICAgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgdGhpcy5jb25zdHJ1Y3QgICAgID0gb3B0aW9uc1snY29uc3RydWN0J10gICAgIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhOyB9O1xuICB0aGlzLmluc3RhbmNlT2YgICAgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gICAgfHwgbnVsbDtcbiAgdGhpcy5wcmVkaWNhdGUgICAgID0gb3B0aW9uc1sncHJlZGljYXRlJ10gICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50ICAgICA9IG9wdGlvbnNbJ3JlcHJlc2VudCddICAgICB8fCBudWxsO1xuICB0aGlzLnJlcHJlc2VudE5hbWUgPSBvcHRpb25zWydyZXByZXNlbnROYW1lJ10gfHwgbnVsbDtcbiAgdGhpcy5kZWZhdWx0U3R5bGUgID0gb3B0aW9uc1snZGVmYXVsdFN0eWxlJ10gIHx8IG51bGw7XG4gIHRoaXMubXVsdGkgICAgICAgICA9IG9wdGlvbnNbJ211bHRpJ10gICAgICAgICB8fCBmYWxzZTtcbiAgdGhpcy5zdHlsZUFsaWFzZXMgID0gY29tcGlsZVN0eWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcblxuICBpZiAoWUFNTF9OT0RFX0tJTkRTLmluZGV4T2YodGhpcy5raW5kKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdVbmtub3duIGtpbmQgXCInICsgdGhpcy5raW5kICsgJ1wiIGlzIHNwZWNpZmllZCBmb3IgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgfVxufVxuXG52YXIgdHlwZSA9IFR5cGUkMTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxuXG5cblxuXG5mdW5jdGlvbiBjb21waWxlTGlzdChzY2hlbWEsIG5hbWUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIHNjaGVtYVtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50VHlwZSkge1xuICAgIHZhciBuZXdJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocHJldmlvdXNUeXBlLCBwcmV2aW91c0luZGV4KSB7XG4gICAgICBpZiAocHJldmlvdXNUeXBlLnRhZyA9PT0gY3VycmVudFR5cGUudGFnICYmXG4gICAgICAgICAgcHJldmlvdXNUeXBlLmtpbmQgPT09IGN1cnJlbnRUeXBlLmtpbmQgJiZcbiAgICAgICAgICBwcmV2aW91c1R5cGUubXVsdGkgPT09IGN1cnJlbnRUeXBlLm11bHRpKSB7XG5cbiAgICAgICAgbmV3SW5kZXggPSBwcmV2aW91c0luZGV4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdWx0W25ld0luZGV4XSA9IGN1cnJlbnRUeXBlO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBpbGVNYXAoLyogbGlzdHMuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgc2NhbGFyOiB7fSxcbiAgICAgICAgc2VxdWVuY2U6IHt9LFxuICAgICAgICBtYXBwaW5nOiB7fSxcbiAgICAgICAgZmFsbGJhY2s6IHt9LFxuICAgICAgICBtdWx0aToge1xuICAgICAgICAgIHNjYWxhcjogW10sXG4gICAgICAgICAgc2VxdWVuY2U6IFtdLFxuICAgICAgICAgIG1hcHBpbmc6IFtdLFxuICAgICAgICAgIGZhbGxiYWNrOiBbXVxuICAgICAgICB9XG4gICAgICB9LCBpbmRleCwgbGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3RUeXBlKHR5cGUpIHtcbiAgICBpZiAodHlwZS5tdWx0aSkge1xuICAgICAgcmVzdWx0Lm11bHRpW3R5cGUua2luZF0ucHVzaCh0eXBlKTtcbiAgICAgIHJlc3VsdC5tdWx0aVsnZmFsbGJhY2snXS5wdXNoKHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRbdHlwZS5raW5kXVt0eXBlLnRhZ10gPSByZXN1bHRbJ2ZhbGxiYWNrJ11bdHlwZS50YWddID0gdHlwZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBhcmd1bWVudHNbaW5kZXhdLmZvckVhY2goY29sbGVjdFR5cGUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gU2NoZW1hJDEoZGVmaW5pdGlvbikge1xuICByZXR1cm4gdGhpcy5leHRlbmQoZGVmaW5pdGlvbik7XG59XG5cblxuU2NoZW1hJDEucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChkZWZpbml0aW9uKSB7XG4gIHZhciBpbXBsaWNpdCA9IFtdO1xuICB2YXIgZXhwbGljaXQgPSBbXTtcblxuICBpZiAoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAvLyBTY2hlbWEuZXh0ZW5kKHR5cGUpXG4gICAgZXhwbGljaXQucHVzaChkZWZpbml0aW9uKTtcblxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICAvLyBTY2hlbWEuZXh0ZW5kKFsgdHlwZTEsIHR5cGUyLCAuLi4gXSlcbiAgICBleHBsaWNpdCA9IGV4cGxpY2l0LmNvbmNhdChkZWZpbml0aW9uKTtcblxuICB9IGVsc2UgaWYgKGRlZmluaXRpb24gJiYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbi5pbXBsaWNpdCkgfHwgQXJyYXkuaXNBcnJheShkZWZpbml0aW9uLmV4cGxpY2l0KSkpIHtcbiAgICAvLyBTY2hlbWEuZXh0ZW5kKHsgZXhwbGljaXQ6IFsgdHlwZTEsIHR5cGUyLCAuLi4gXSwgaW1wbGljaXQ6IFsgdHlwZTEsIHR5cGUyLCAuLi4gXSB9KVxuICAgIGlmIChkZWZpbml0aW9uLmltcGxpY2l0KSBpbXBsaWNpdCA9IGltcGxpY2l0LmNvbmNhdChkZWZpbml0aW9uLmltcGxpY2l0KTtcbiAgICBpZiAoZGVmaW5pdGlvbi5leHBsaWNpdCkgZXhwbGljaXQgPSBleHBsaWNpdC5jb25jYXQoZGVmaW5pdGlvbi5leHBsaWNpdCk7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdTY2hlbWEuZXh0ZW5kIGFyZ3VtZW50IHNob3VsZCBiZSBhIFR5cGUsIFsgVHlwZSBdLCAnICtcbiAgICAgICdvciBhIHNjaGVtYSBkZWZpbml0aW9uICh7IGltcGxpY2l0OiBbLi4uXSwgZXhwbGljaXQ6IFsuLi5dIH0pJyk7XG4gIH1cblxuICBpbXBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlJDEpIHtcbiAgICBpZiAoISh0eXBlJDEgaW5zdGFuY2VvZiB0eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlJDEubG9hZEtpbmQgJiYgdHlwZSQxLmxvYWRLaW5kICE9PSAnc2NhbGFyJykge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignVGhlcmUgaXMgYSBub24tc2NhbGFyIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIEltcGxpY2l0IHJlc29sdmluZyBvZiBzdWNoIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUkMS5tdWx0aSkge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignVGhlcmUgaXMgYSBtdWx0aSB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBNdWx0aSB0YWdzIGNhbiBvbmx5IGJlIGxpc3RlZCBhcyBleHBsaWNpdC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV4cGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUkMSkge1xuICAgIGlmICghKHR5cGUkMSBpbnN0YW5jZW9mIHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBZQU1MIHR5cGVzIChvciBhIHNpbmdsZSBUeXBlIG9iamVjdCkgY29udGFpbnMgYSBub24tVHlwZSBvYmplY3QuJyk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShTY2hlbWEkMS5wcm90b3R5cGUpO1xuXG4gIHJlc3VsdC5pbXBsaWNpdCA9ICh0aGlzLmltcGxpY2l0IHx8IFtdKS5jb25jYXQoaW1wbGljaXQpO1xuICByZXN1bHQuZXhwbGljaXQgPSAodGhpcy5leHBsaWNpdCB8fCBbXSkuY29uY2F0KGV4cGxpY2l0KTtcblxuICByZXN1bHQuY29tcGlsZWRJbXBsaWNpdCA9IGNvbXBpbGVMaXN0KHJlc3VsdCwgJ2ltcGxpY2l0Jyk7XG4gIHJlc3VsdC5jb21waWxlZEV4cGxpY2l0ID0gY29tcGlsZUxpc3QocmVzdWx0LCAnZXhwbGljaXQnKTtcbiAgcmVzdWx0LmNvbXBpbGVkVHlwZU1hcCAgPSBjb21waWxlTWFwKHJlc3VsdC5jb21waWxlZEltcGxpY2l0LCByZXN1bHQuY29tcGlsZWRFeHBsaWNpdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxudmFyIHNjaGVtYSA9IFNjaGVtYSQxO1xuXG52YXIgc3RyID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogJyc7IH1cbn0pO1xuXG52YXIgc2VxID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTsgfVxufSk7XG5cbnZhciBtYXAgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307IH1cbn0pO1xuXG52YXIgZmFpbHNhZmUgPSBuZXcgc2NoZW1hKHtcbiAgZXhwbGljaXQ6IFtcbiAgICBzdHIsXG4gICAgc2VxLFxuICAgIG1hcFxuICBdXG59KTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxOdWxsKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gMSAmJiBkYXRhID09PSAnficpIHx8XG4gICAgICAgICAobWF4ID09PSA0ICYmIChkYXRhID09PSAnbnVsbCcgfHwgZGF0YSA9PT0gJ051bGwnIHx8IGRhdGEgPT09ICdOVUxMJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PT0gbnVsbDtcbn1cblxudmFyIF9udWxsID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE51bGwsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE51bGwsXG4gIHByZWRpY2F0ZTogaXNOdWxsLFxuICByZXByZXNlbnQ6IHtcbiAgICBjYW5vbmljYWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd+JzsgICAgfSxcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdudWxsJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOVUxMJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOdWxsJzsgfSxcbiAgICBlbXB0eTogICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuICcnOyAgICAgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSkgfHxcbiAgICAgICAgIChtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCb29sZWFuKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICd0cnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBCb29sZWFuXSc7XG59XG5cbnZhciBib29sID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICd0cnVlJyA6ICdmYWxzZSc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVFJVRScgOiAnRkFMU0UnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RydWUnIDogJ0ZhbHNlJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxuZnVuY3Rpb24gaXNIZXhDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB8fFxuICAgICAgICAgKCgweDQxLyogQSAqLyA8PSBjKSAmJiAoYyA8PSAweDQ2LyogRiAqLykpIHx8XG4gICAgICAgICAoKDB4NjEvKiBhICovIDw9IGMpICYmIChjIDw9IDB4NjYvKiBmICovKSk7XG59XG5cbmZ1bmN0aW9uIGlzT2N0Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzcvKiA3ICovKSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVjQ29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sSW50ZWdlcihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaGFzRGlnaXRzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAoIW1heCkgcmV0dXJuIGZhbHNlO1xuXG4gIGNoID0gZGF0YVtpbmRleF07XG5cbiAgLy8gc2lnblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICAvLyAwXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gbWF4KSByZXR1cm4gdHJ1ZTtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG5cbiAgICAvLyBiYXNlIDIsIGJhc2UgOCwgYmFzZSAxNlxuXG4gICAgaWYgKGNoID09PSAnYicpIHtcbiAgICAgIC8vIGJhc2UgMlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuXG4gICAgaWYgKGNoID09PSAneCcpIHtcbiAgICAgIC8vIGJhc2UgMTZcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmICghaXNIZXhDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICdvJykge1xuICAgICAgLy8gYmFzZSA4XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJhc2UgMTAgKGV4Y2VwdCAwKVxuXG4gIC8vIHZhbHVlIHNob3VsZCBub3Qgc3RhcnQgd2l0aCBgX2A7XG4gIGlmIChjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKCFpc0RlY0NvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFNob3VsZCBoYXZlIGRpZ2l0cyBhbmQgc2hvdWxkIG5vdCBlbmQgd2l0aCBgX2BcbiAgaWYgKCFoYXNEaWdpdHMgfHwgY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sSW50ZWdlcihkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEsIHNpZ24gPSAxLCBjaDtcblxuICBpZiAodmFsdWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gIH1cblxuICBjaCA9IHZhbHVlWzBdO1xuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBpZiAoY2ggPT09ICctJykgc2lnbiA9IC0xO1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgY2ggPSB2YWx1ZVswXTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJzAnKSByZXR1cm4gMDtcblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ2InKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAyKTtcbiAgICBpZiAodmFsdWVbMV0gPT09ICd4JykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMTYpO1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ28nKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCA4KTtcbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiZcbiAgICAgICAgIChvYmplY3QgJSAxID09PSAwICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbnZhciBpbnQgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6aW50Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxJbnRlZ2VyLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxJbnRlZ2VyLFxuICBwcmVkaWNhdGU6IGlzSW50ZWdlcixcbiAgcmVwcmVzZW50OiB7XG4gICAgYmluYXJ5OiAgICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzBiJyArIG9iai50b1N0cmluZygyKSA6ICctMGInICsgb2JqLnRvU3RyaW5nKDIpLnNsaWNlKDEpOyB9LFxuICAgIG9jdGFsOiAgICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcwbycgICsgb2JqLnRvU3RyaW5nKDgpIDogJy0wbycgICsgb2JqLnRvU3RyaW5nKDgpLnNsaWNlKDEpOyB9LFxuICAgIGRlY2ltYWw6ICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmoudG9TdHJpbmcoMTApOyB9LFxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBoZXhhZGVjaW1hbDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMHgnICsgb2JqLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpIDogICctMHgnICsgb2JqLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnNsaWNlKDEpOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2RlY2ltYWwnLFxuICBzdHlsZUFsaWFzZXM6IHtcbiAgICBiaW5hcnk6ICAgICAgWyAyLCAgJ2JpbicgXSxcbiAgICBvY3RhbDogICAgICAgWyA4LCAgJ29jdCcgXSxcbiAgICBkZWNpbWFsOiAgICAgWyAxMCwgJ2RlYycgXSxcbiAgICBoZXhhZGVjaW1hbDogWyAxNiwgJ2hleCcgXVxuICB9XG59KTtcblxudmFyIFlBTUxfRkxPQVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoXG4gIC8vIDIuNWU0LCAyLjUgYW5kIGludGVnZXJzXG4gICdeKD86Wy0rXT8oPzpbMC05XVswLTlfXSopKD86XFxcXC5bMC05X10qKT8oPzpbZUVdWy0rXT9bMC05XSspPycgK1xuICAvLyAuMmU0LCAuMlxuICAvLyBzcGVjaWFsIGNhc2UsIHNlZW1zIG5vdCBmcm9tIHNwZWNcbiAgJ3xcXFxcLlswLTlfXSsoPzpbZUVdWy0rXT9bMC05XSspPycgK1xuICAvLyAuaW5mXG4gICd8Wy0rXT9cXFxcLig/OmluZnxJbmZ8SU5GKScgK1xuICAvLyAubmFuXG4gICd8XFxcXC4oPzpuYW58TmFOfE5BTikpJCcpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEZsb2F0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoIVlBTUxfRkxPQVRfUEFUVEVSTi50ZXN0KGRhdGEpIHx8XG4gICAgICAvLyBRdWljayBoYWNrIHRvIG5vdCBhbGxvdyBpbnRlZ2VycyBlbmQgd2l0aCBgX2BcbiAgICAgIC8vIFByb2JhYmx5IHNob3VsZCB1cGRhdGUgcmVnZXhwICYgY2hlY2sgc3BlZWRcbiAgICAgIGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gJ18nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxGbG9hdChkYXRhKSB7XG4gIHZhciB2YWx1ZSwgc2lnbjtcblxuICB2YWx1ZSAgPSBkYXRhLnJlcGxhY2UoL18vZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIHNpZ24gICA9IHZhbHVlWzBdID09PSAnLScgPyAtMSA6IDE7XG5cbiAgaWYgKCcrLScuaW5kZXhPZih2YWx1ZVswXSkgPj0gMCkge1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcuaW5mJykge1xuICAgIHJldHVybiAoc2lnbiA9PT0gMSkgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJy5uYW4nKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbn1cblxuXG52YXIgU0NJRU5USUZJQ19XSVRIT1VUX0RPVCA9IC9eWy0rXT9bMC05XStlLztcblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgdmFyIHJlcztcblxuICBpZiAoaXNOYU4ob2JqZWN0KSkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLm5hbic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5OQU4nO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuTmFOJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICctLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy0uSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLS5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSkge1xuICAgIHJldHVybiAnLTAuMCc7XG4gIH1cblxuICByZXMgPSBvYmplY3QudG9TdHJpbmcoMTApO1xuXG4gIC8vIEpTIHN0cmluZ2lmaWVyIGNhbiBidWlsZCBzY2llbnRpZmljIGZvcm1hdCB3aXRob3V0IGRvdHM6IDVlLTEwMCxcbiAgLy8gd2hpbGUgWUFNTCByZXF1cmVzIGRvdDogNS5lLTEwMC4gRml4IGl0IHdpdGggc2ltcGxlIGhhY2tcblxuICByZXR1cm4gU0NJRU5USUZJQ19XSVRIT1VUX0RPVC50ZXN0KHJlcykgPyByZXMucmVwbGFjZSgnZScsICcuZScpIDogcmVzO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBOdW1iZXJdJykgJiZcbiAgICAgICAgIChvYmplY3QgJSAxICE9PSAwIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxudmFyIGZsb2F0ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxGbG9hdCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sRmxvYXQsXG4gIHByZWRpY2F0ZTogaXNGbG9hdCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sRmxvYXQsXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG52YXIganNvbiA9IGZhaWxzYWZlLmV4dGVuZCh7XG4gIGltcGxpY2l0OiBbXG4gICAgX251bGwsXG4gICAgYm9vbCxcbiAgICBpbnQsXG4gICAgZmxvYXRcbiAgXVxufSk7XG5cbnZhciBjb3JlID0ganNvbjtcblxudmFyIFlBTUxfREFURV9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldKSQnKTsgICAgICAgICAgICAgICAgICAgLy8gWzNdIGRheVxuXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcbiAgJyg/OltUdF18WyBcXFxcdF0rKScgICAgICAgICAgICAgICAgICsgLy8gLi4uXG4gICcoWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNF0gaG91clxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzZdIHNlY29uZFxuICAnKD86XFxcXC4oWzAtOV0qKSk/JyAgICAgICAgICAgICAgICAgKyAvLyBbN10gZnJhY3Rpb25cbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuICAnKD86OihbMC05XVswLTldKSk/KSk/JCcpOyAgICAgICAgICAgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24gPSAwLFxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGU7XG5cbiAgbWF0Y2ggPSBZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignRGF0ZSByZXNvbHZlIGVycm9yJyk7XG5cbiAgLy8gbWF0Y2g6IFsxXSB5ZWFyIFsyXSBtb250aCBbM10gZGF5XG5cbiAgeWVhciA9ICsobWF0Y2hbMV0pO1xuICBtb250aCA9ICsobWF0Y2hbMl0pIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxuICBkYXkgPSArKG1hdGNoWzNdKTtcblxuICBpZiAoIW1hdGNoWzRdKSB7IC8vIG5vIGhvdXJcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs0XSBob3VyIFs1XSBtaW51dGUgWzZdIHNlY29uZCBbN10gZnJhY3Rpb25cblxuICBob3VyID0gKyhtYXRjaFs0XSk7XG4gIG1pbnV0ZSA9ICsobWF0Y2hbNV0pO1xuICBzZWNvbmQgPSArKG1hdGNoWzZdKTtcblxuICBpZiAobWF0Y2hbN10pIHtcbiAgICBmcmFjdGlvbiA9IG1hdGNoWzddLnNsaWNlKDAsIDMpO1xuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCAzKSB7IC8vIG1pbGxpLXNlY29uZHNcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICB9XG4gICAgZnJhY3Rpb24gPSArZnJhY3Rpb247XG4gIH1cblxuICAvLyBtYXRjaDogWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91ciBbMTFdIHR6X21pbnV0ZVxuXG4gIGlmIChtYXRjaFs5XSkge1xuICAgIHR6X2hvdXIgPSArKG1hdGNoWzEwXSk7XG4gICAgdHpfbWludXRlID0gKyhtYXRjaFsxMV0gfHwgMCk7XG4gICAgZGVsdGEgPSAodHpfaG91ciAqIDYwICsgdHpfbWludXRlKSAqIDYwMDAwOyAvLyBkZWx0YSBpbiBtaWxpLXNlY29uZHNcbiAgICBpZiAobWF0Y2hbOV0gPT09ICctJykgZGVsdGEgPSAtZGVsdGE7XG4gIH1cblxuICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uKSk7XG5cbiAgaWYgKGRlbHRhKSBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbn1cblxudmFyIHRpbWVzdGFtcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFRpbWVzdGFtcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wLFxuICBpbnN0YW5jZU9mOiBEYXRlLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxUaW1lc3RhbXBcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE1lcmdlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICc8PCcgfHwgZGF0YSA9PT0gbnVsbDtcbn1cblxudmFyIG1lcmdlID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxNZXJnZVxufSk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG5cblxuXG5cblxuLy8gWyA2NCwgNjUsIDY2IF0gLT4gWyBwYWRkaW5nLCBDUiwgTEYgXVxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cXG5cXHInO1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQmluYXJ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgY29kZSwgaWR4LCBiaXRsZW4gPSAwLCBtYXggPSBkYXRhLmxlbmd0aCwgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IG9uZSBieSBvbmUuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTtcblxuICAgIC8vIFNraXAgQ1IvTEZcbiAgICBpZiAoY29kZSA+IDY0KSBjb250aW51ZTtcblxuICAgIC8vIEZhaWwgb24gaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBiaXRsZW4gKz0gNjtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCBzb3VyY2Ugd2FzIGNvcnJ1cHRlZFxuICByZXR1cm4gKGJpdGxlbiAlIDgpID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGlkeCwgdGFpbGJpdHMsXG4gICAgICBpbnB1dCA9IGRhdGEucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQLFxuICAgICAgYml0cyA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbGJpdHMgPSAobWF4ICUgNCkgKiA2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sQmluYXJ5KG9iamVjdCAvKiwgc3R5bGUqLykge1xuICB2YXIgcmVzdWx0ID0gJycsIGJpdHMgPSAwLCBpZHgsIHRhaWwsXG4gICAgICBtYXggPSBvYmplY3QubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IGV2ZXJ5IHRocmVlIGJ5dGVzIHRvIDQgQVNDSUkgY2hhcmFjdGVycy5cblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBpZiAoKGlkeCAlIDMgPT09IDApICYmIGlkeCkge1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxOCkgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwW2JpdHMgJiAweDNGXTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgOCkgKyBvYmplY3RbaWR4XTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHRhaWwgPSBtYXggJSAzO1xuXG4gIGlmICh0YWlsID09PSAwKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxOCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgJiAweDNGXTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAyKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA8PCAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDEpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA8PCA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNCaW5hcnkob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gICdbb2JqZWN0IFVpbnQ4QXJyYXldJztcbn1cblxudmFyIGJpbmFyeSA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJpbmFyeSxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQmluYXJ5LFxuICBwcmVkaWNhdGU6IGlzQmluYXJ5LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxCaW5hcnlcbn0pO1xuXG52YXIgX2hhc093blByb3BlcnR5JDMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF90b1N0cmluZyQyICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBvYmplY3RLZXlzID0gW10sIGluZGV4LCBsZW5ndGgsIHBhaXIsIHBhaXJLZXksIHBhaXJIYXNLZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcblxuICAgIGlmIChfdG9TdHJpbmckMi5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChwYWlyS2V5IGluIHBhaXIpIHtcbiAgICAgIGlmIChfaGFzT3duUHJvcGVydHkkMy5jYWxsKHBhaXIsIHBhaXJLZXkpKSB7XG4gICAgICAgIGlmICghcGFpckhhc0tleSkgcGFpckhhc0tleSA9IHRydWU7XG4gICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFpckhhc0tleSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKG9iamVjdEtleXMuaW5kZXhPZihwYWlyS2V5KSA9PT0gLTEpIG9iamVjdEtleXMucHVzaChwYWlyS2V5KTtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sT21hcChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdO1xufVxuXG52YXIgb21hcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE9tYXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE9tYXBcbn0pO1xuXG52YXIgX3RvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChfdG9TdHJpbmckMS5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgcGFpcnMgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sUGFpcnMsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFBhaXJzXG59KTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxTZXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGtleSwgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5JDIuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIGlmIChvYmplY3Rba2V5XSAhPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sU2V0KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307XG59XG5cbnZhciBzZXQgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2V0Jywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sU2V0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxTZXRcbn0pO1xuXG52YXIgX2RlZmF1bHQgPSBjb3JlLmV4dGVuZCh7XG4gIGltcGxpY2l0OiBbXG4gICAgdGltZXN0YW1wLFxuICAgIG1lcmdlXG4gIF0sXG4gIGV4cGxpY2l0OiBbXG4gICAgYmluYXJ5LFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2V0XG4gIF1cbn0pO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4sbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG5cblxuXG5cblxuXG52YXIgX2hhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cbnZhciBDT05URVhUX0ZMT1dfSU4gICA9IDE7XG52YXIgQ09OVEVYVF9GTE9XX09VVCAgPSAyO1xudmFyIENPTlRFWFRfQkxPQ0tfSU4gID0gMztcbnZhciBDT05URVhUX0JMT0NLX09VVCA9IDQ7XG5cblxudmFyIENIT01QSU5HX0NMSVAgID0gMTtcbnZhciBDSE9NUElOR19TVFJJUCA9IDI7XG52YXIgQ0hPTVBJTkdfS0VFUCAgPSAzO1xuXG5cbnZhciBQQVRURVJOX05PTl9QUklOVEFCTEUgICAgICAgICA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZcXHg3Ri1cXHg4NFxceDg2LVxceDlGXFx1RkZGRVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLztcbnZhciBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUyA9IC9bXFx4ODVcXHUyMDI4XFx1MjAyOV0vO1xudmFyIFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTICAgICAgID0gL1ssXFxbXFxdXFx7XFx9XS87XG52YXIgUEFUVEVSTl9UQUdfSEFORExFICAgICAgICAgICAgPSAvXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pO1xudmFyIFBBVFRFUk5fVEFHX1VSSSAgICAgICAgICAgICAgID0gL14oPzohfFteLFxcW1xcXVxce1xcfV0pKD86JVswLTlhLWZdezJ9fFswLTlhLXpcXC0jO1xcL1xcPzpAJj1cXCtcXCQsX1xcLiF+XFwqJ1xcKFxcKVxcW1xcXV0pKiQvaTtcblxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuXG5mdW5jdGlvbiBpc19FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MEEvKiBMRiAqLykgfHwgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dISVRFX1NQQUNFKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fCAoYyA9PT0gMHgyMC8qIFNwYWNlICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV1NfT1JfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBBLyogTEYgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfRkxPV19JTkRJQ0FUT1IoYykge1xuICByZXR1cm4gYyA9PT0gMHgyQy8qICwgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUIvKiBbICovIHx8XG4gICAgICAgICBjID09PSAweDVELyogXSAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3Qi8qIHsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0QvKiB9ICovO1xufVxuXG5mdW5jdGlvbiBmcm9tSGV4Q29kZShjKSB7XG4gIHZhciBsYztcblxuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG4gIGxjID0gYyB8IDB4MjA7XG5cbiAgaWYgKCgweDYxLyogYSAqLyA8PSBsYykgJiYgKGxjIDw9IDB4NjYvKiBmICovKSkge1xuICAgIHJldHVybiBsYyAtIDB4NjEgKyAxMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZEhleExlbihjKSB7XG4gIGlmIChjID09PSAweDc4LyogeCAqLykgeyByZXR1cm4gMjsgfVxuICBpZiAoYyA9PT0gMHg3NS8qIHUgKi8pIHsgcmV0dXJuIDQ7IH1cbiAgaWYgKGMgPT09IDB4NTUvKiBVICovKSB7IHJldHVybiA4OyB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVjaW1hbENvZGUoYykge1xuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRXNjYXBlU2VxdWVuY2UoYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbiAgcmV0dXJuIChjID09PSAweDMwLyogMCAqLykgPyAnXFx4MDAnIDpcbiAgICAgICAgKGMgPT09IDB4NjEvKiBhICovKSA/ICdcXHgwNycgOlxuICAgICAgICAoYyA9PT0gMHg2Mi8qIGIgKi8pID8gJ1xceDA4JyA6XG4gICAgICAgIChjID09PSAweDc0LyogdCAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4MDkvKiBUYWIgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDZFLyogbiAqLykgPyAnXFx4MEEnIDpcbiAgICAgICAgKGMgPT09IDB4NzYvKiB2ICovKSA/ICdcXHgwQicgOlxuICAgICAgICAoYyA9PT0gMHg2Ni8qIGYgKi8pID8gJ1xceDBDJyA6XG4gICAgICAgIChjID09PSAweDcyLyogciAqLykgPyAnXFx4MEQnIDpcbiAgICAgICAgKGMgPT09IDB4NjUvKiBlICovKSA/ICdcXHgxQicgOlxuICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSA/ICcgJyA6XG4gICAgICAgIChjID09PSAweDIyLyogXCIgKi8pID8gJ1xceDIyJyA6XG4gICAgICAgIChjID09PSAweDJGLyogLyAqLykgPyAnLycgOlxuICAgICAgICAoYyA9PT0gMHg1Qy8qIFxcICovKSA/ICdcXHg1QycgOlxuICAgICAgICAoYyA9PT0gMHg0RS8qIE4gKi8pID8gJ1xceDg1JyA6XG4gICAgICAgIChjID09PSAweDVGLyogXyAqLykgPyAnXFx4QTAnIDpcbiAgICAgICAgKGMgPT09IDB4NEMvKiBMICovKSA/ICdcXHUyMDI4JyA6XG4gICAgICAgIChjID09PSAweDUwLyogUCAqLykgPyAnXFx1MjAyOScgOiAnJztcbn1cblxuZnVuY3Rpb24gY2hhckZyb21Db2RlcG9pbnQoYykge1xuICBpZiAoYyA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgfVxuICAvLyBFbmNvZGUgVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi0xNiNDb2RlX3BvaW50c19VLjJCMDEwMDAwX3RvX1UuMkIxMEZGRkZcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgKChjIC0gMHgwMTAwMDApID4+IDEwKSArIDB4RDgwMCxcbiAgICAoKGMgLSAweDAxMDAwMCkgJiAweDAzRkYpICsgMHhEQzAwXG4gICk7XG59XG5cbi8vIHNldCBhIHByb3BlcnR5IG9mIGEgbGl0ZXJhbCBvYmplY3QsIHdoaWxlIHByb3RlY3RpbmcgYWdhaW5zdCBwcm90b3R5cGUgcG9sbHV0aW9uLFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvanMteWFtbC9pc3N1ZXMvMTY0IGZvciBtb3JlIGRldGFpbHNcbmZ1bmN0aW9uIHNldFByb3BlcnR5KG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAvLyB1c2VkIGZvciB0aGlzIHNwZWNpZmljIGtleSBvbmx5IGJlY2F1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGlzIHNsb3dcbiAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xudmFyIHNpbXBsZUVzY2FwZU1hcCA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBzaW1wbGVFc2NhcGVDaGVja1tpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpID8gMSA6IDA7XG4gIHNpbXBsZUVzY2FwZU1hcFtpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gIHRoaXMuZmlsZW5hbWUgID0gb3B0aW9uc1snZmlsZW5hbWUnXSAgfHwgbnVsbDtcbiAgdGhpcy5zY2hlbWEgICAgPSBvcHRpb25zWydzY2hlbWEnXSAgICB8fCBfZGVmYXVsdDtcbiAgdGhpcy5vbldhcm5pbmcgPSBvcHRpb25zWydvbldhcm5pbmcnXSB8fCBudWxsO1xuICAvLyAoSGlkZGVuKSBSZW1vdmU/IG1ha2VzIHRoZSBsb2FkZXIgdG8gZXhwZWN0IFlBTUwgMS4xIGRvY3VtZW50c1xuICAvLyBpZiBzdWNoIGRvY3VtZW50cyBoYXZlIG5vIGV4cGxpY2l0ICVZQU1MIGRpcmVjdGl2ZVxuICB0aGlzLmxlZ2FjeSAgICA9IG9wdGlvbnNbJ2xlZ2FjeSddICAgIHx8IGZhbHNlO1xuXG4gIHRoaXMuanNvbiAgICAgID0gb3B0aW9uc1snanNvbiddICAgICAgfHwgZmFsc2U7XG4gIHRoaXMubGlzdGVuZXIgID0gb3B0aW9uc1snbGlzdGVuZXInXSAgfHwgbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLnR5cGVNYXAgICAgICAgPSB0aGlzLnNjaGVtYS5jb21waWxlZFR5cGVNYXA7XG5cbiAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnBvc2l0aW9uICAgPSAwO1xuICB0aGlzLmxpbmUgICAgICAgPSAwO1xuICB0aGlzLmxpbmVTdGFydCAgPSAwO1xuICB0aGlzLmxpbmVJbmRlbnQgPSAwO1xuXG4gIC8vIHBvc2l0aW9uIG9mIGZpcnN0IGxlYWRpbmcgdGFiIGluIHRoZSBjdXJyZW50IGxpbmUsXG4gIC8vIHVzZWQgdG8gbWFrZSBzdXJlIHRoZXJlIGFyZSBubyB0YWJzIGluIHRoZSBpbmRlbnRhdGlvblxuICB0aGlzLmZpcnN0VGFiSW5MaW5lID0gLTE7XG5cbiAgdGhpcy5kb2N1bWVudHMgPSBbXTtcblxuICAvKlxuICB0aGlzLnZlcnNpb247XG4gIHRoaXMuY2hlY2tMaW5lQnJlYWtzO1xuICB0aGlzLnRhZ01hcDtcbiAgdGhpcy5hbmNob3JNYXA7XG4gIHRoaXMudGFnO1xuICB0aGlzLmFuY2hvcjtcbiAgdGhpcy5raW5kO1xuICB0aGlzLnJlc3VsdDsqL1xuXG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB2YXIgbWFyayA9IHtcbiAgICBuYW1lOiAgICAgc3RhdGUuZmlsZW5hbWUsXG4gICAgYnVmZmVyOiAgIHN0YXRlLmlucHV0LnNsaWNlKDAsIC0xKSwgLy8gb21pdCB0cmFpbGluZyBcXDBcbiAgICBwb3NpdGlvbjogc3RhdGUucG9zaXRpb24sXG4gICAgbGluZTogICAgIHN0YXRlLmxpbmUsXG4gICAgY29sdW1uOiAgIHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0XG4gIH07XG5cbiAgbWFyay5zbmlwcGV0ID0gc25pcHBldChtYXJrKTtcblxuICByZXR1cm4gbmV3IGV4Y2VwdGlvbihtZXNzYWdlLCBtYXJrKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgaWYgKG1pbm9yICE9PSAxICYmIG1pbm9yICE9PSAyKSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuICB9LFxuXG4gIFRBRzogZnVuY3Rpb24gaGFuZGxlVGFnRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50YWdNYXAsIGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGVyZSBpcyBhIHByZXZpb3VzbHkgZGVjbGFyZWQgc3VmZml4IGZvciBcIicgKyBoYW5kbGUgKyAnXCIgdGFnIGhhbmRsZScpO1xuICAgIH1cblxuICAgIGlmICghUEFUVEVSTl9UQUdfVVJJLnRlc3QocHJlZml4KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIHByZWZpeCAoc2Vjb25kIGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcmVmaXggPSBkZWNvZGVVUklDb21wb25lbnQocHJlZml4KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgcHJlZml4IGlzIG1hbGZvcm1lZDogJyArIHByZWZpeCk7XG4gICAgfVxuXG4gICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gY2FwdHVyZVNlZ21lbnQoc3RhdGUsIHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xuICB2YXIgX3Bvc2l0aW9uLCBfbGVuZ3RoLCBfY2hhcmFjdGVyLCBfcmVzdWx0O1xuXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIF9yZXN1bHQgPSBzdGF0ZS5pbnB1dC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChjaGVja0pzb24pIHtcbiAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoOyBfcG9zaXRpb24gPCBfbGVuZ3RoOyBfcG9zaXRpb24gKz0gMSkge1xuICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG4gICAgICAgIGlmICghKF9jaGFyYWN0ZXIgPT09IDB4MDkgfHxcbiAgICAgICAgICAgICAgKDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3QoX3Jlc3VsdCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJyaWRhYmxlS2V5cykge1xuICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XG5cbiAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xuICB9XG5cbiAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcblxuICAgIGlmICghX2hhc093blByb3BlcnR5JDEuY2FsbChkZXN0aW5hdGlvbiwga2V5KSkge1xuICAgICAgc2V0UHJvcGVydHkoZGVzdGluYXRpb24sIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgb3ZlcnJpZGFibGVLZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLFxuICBzdGFydExpbmUsIHN0YXJ0TGluZVN0YXJ0LCBzdGFydFBvcykge1xuXG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAgLy8gVGhlIG91dHB1dCBpcyBhIHBsYWluIG9iamVjdCBoZXJlLCBzbyBrZXlzIGNhbiBvbmx5IGJlIHN0cmluZ3MuXG4gIC8vIFdlIG5lZWQgdG8gY29udmVydCBrZXlOb2RlIHRvIGEgc3RyaW5nLCBidXQgZG9pbmcgc28gY2FuIGhhbmcgdGhlIHByb2Nlc3NcbiAgLy8gKGRlZXBseSBuZXN0ZWQgYXJyYXlzIHRoYXQgZXhwbG9kZSBleHBvbmVudGlhbGx5IHVzaW5nIGFsaWFzZXMpLlxuICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlKSkge1xuICAgIGtleU5vZGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChrZXlOb2RlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IGtleU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlW2luZGV4XSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGtleXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZVtpbmRleF0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICBrZXlOb2RlW2luZGV4XSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEF2b2lkIGNvZGUgZXhlY3V0aW9uIGluIGxvYWQoKSB2aWEgdG9TdHJpbmcgcHJvcGVydHlcbiAgLy8gKHN0aWxsIHVzZSBpdHMgb3duIHRvU3RyaW5nIGZvciBhcnJheXMsIHRpbWVzdGFtcHMsXG4gIC8vIGFuZCB3aGF0ZXZlciB1c2VyIHNjaGVtYSBleHRlbnNpb25zIGhhcHBlbiB0byBoYXZlIEBAdG9TdHJpbmdUYWcpXG4gIGlmICh0eXBlb2Yga2V5Tm9kZSA9PT0gJ29iamVjdCcgJiYgX2NsYXNzKGtleU5vZGUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGtleU5vZGUgPSAnW29iamVjdCBPYmplY3RdJztcbiAgfVxuXG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAoX3Jlc3VsdCA9PT0gbnVsbCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmIChrZXlUYWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0sIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzdGF0ZS5qc29uICYmXG4gICAgICAgICFfaGFzT3duUHJvcGVydHkkMS5jYWxsKG92ZXJyaWRhYmxlS2V5cywga2V5Tm9kZSkgJiZcbiAgICAgICAgX2hhc093blByb3BlcnR5JDEuY2FsbChfcmVzdWx0LCBrZXlOb2RlKSkge1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSB8fCBzdGF0ZS5saW5lO1xuICAgICAgc3RhdGUubGluZVN0YXJ0ID0gc3RhcnRMaW5lU3RhcnQgfHwgc3RhdGUubGluZVN0YXJ0O1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGFydFBvcyB8fCBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGVkIG1hcHBpbmcga2V5Jyk7XG4gICAgfVxuXG4gICAgc2V0UHJvcGVydHkoX3Jlc3VsdCwga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICBkZWxldGUgb3ZlcnJpZGFibGVLZXlzW2tleU5vZGVdO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDBBLyogTEYgKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDBELyogQ1IgKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBzdGF0ZS5saW5lICs9IDE7XG4gIHN0YXRlLmxpbmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuICBzdGF0ZS5maXJzdFRhYkluTGluZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBhbGxvd0NvbW1lbnRzLCBjaGVja0luZGVudCkge1xuICB2YXIgbGluZUJyZWFrcyA9IDAsXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgwOS8qIFRhYiAqLyAmJiBzdGF0ZS5maXJzdFRhYkluTGluZSA9PT0gLTEpIHtcbiAgICAgICAgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dDb21tZW50cyAmJiBjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSB3aGlsZSAoY2ggIT09IDB4MEEvKiBMRiAqLyAmJiBjaCAhPT0gMHgwRC8qIENSICovICYmIGNoICE9PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKGNoID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjaGVja0luZGVudCAhPT0gLTEgJiYgbGluZUJyZWFrcyAhPT0gMCAmJiBzdGF0ZS5saW5lSW5kZW50IDwgY2hlY2tJbmRlbnQpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdkZWZpY2llbnQgaW5kZW50YXRpb24nKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lQnJlYWtzO1xufVxuXG5mdW5jdGlvbiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG4gIGlmICgoY2ggPT09IDB4MkQvKiAtICovIHx8IGNoID09PSAweDJFLyogLiAqLykgJiZcbiAgICAgIGNoID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDEpICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAyKSkge1xuXG4gICAgX3Bvc2l0aW9uICs9IDM7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMCB8fCBpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIGNvdW50KSB7XG4gIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gIH0gZWxzZSBpZiAoY291bnQgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGNvdW50IC0gMSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWFkUGxhaW5TY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XG4gIHZhciBwcmVjZWRpbmcsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfbGluZUluZGVudCxcbiAgICAgIF9raW5kID0gc3RhdGUua2luZCxcbiAgICAgIF9yZXN1bHQgPSBzdGF0ZS5yZXN1bHQsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChpc19XU19PUl9FT0woY2gpICAgICAgfHxcbiAgICAgIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSB8fFxuICAgICAgY2ggPT09IDB4MjMvKiAjICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNi8qICYgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDJBLyogKiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjEvKiAhICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg3Qy8qIHwgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDNFLyogPiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjcvKiAnICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyMi8qIFwiICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNS8qICUgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDQwLyogQCAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4NjAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSB8fFxuICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgcHJlY2VkaW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiAtIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKHByZWNlZGluZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHx8XG4gICAgICAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICAgIGJyZWFrO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgX2xpbmVJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIC0xKTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPj0gbm9kZUluZGVudCkge1xuICAgICAgICBoYXNQZW5kaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucG9zaXRpb24gPSBjYXB0dXJlRW5kO1xuICAgICAgICBzdGF0ZS5saW5lID0gX2xpbmU7XG4gICAgICAgIHN0YXRlLmxpbmVTdGFydCA9IF9saW5lU3RhcnQ7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSBfbGluZUluZGVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdDb250ZW50KSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBzdGF0ZS5saW5lIC0gX2xpbmUpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG5cbiAgaWYgKHN0YXRlLnJlc3VsdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9IF9raW5kO1xuICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI3LyogJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjcvKiAnICovKSB7XG4gICAgICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoZXhMZW5ndGgsXG4gICAgICBoZXhSZXN1bHQsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyMi8qIFwiICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4MjIvKiBcIiAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1Qy8qIFxcICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KTtcblxuICAgICAgICAvLyBUT0RPOiByZXdvcmsgdG8gaW5saW5lIGZuIHdpdGggbm8gdHlwZSBjYXN0P1xuICAgICAgfSBlbHNlIGlmIChjaCA8IDI1NiAmJiBzaW1wbGVFc2NhcGVDaGVja1tjaF0pIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IHNpbXBsZUVzY2FwZU1hcFtjaF07XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSBpZiAoKHRtcCA9IGVzY2FwZWRIZXhMZW4oY2gpKSA+IDApIHtcbiAgICAgICAgaGV4TGVuZ3RoID0gdG1wO1xuICAgICAgICBoZXhSZXN1bHQgPSAwO1xuXG4gICAgICAgIGZvciAoOyBoZXhMZW5ndGggPiAwOyBoZXhMZW5ndGgtLSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICgodG1wID0gZnJvbUhleENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICAgICAgICBoZXhSZXN1bHQgPSAoaGV4UmVzdWx0IDw8IDQpICsgdG1wO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY2hhckZyb21Db2RlcG9pbnQoaGV4UmVzdWx0KTtcblxuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biBlc2NhcGUgc2VxdWVuY2UnKTtcbiAgICAgIH1cblxuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciByZWFkTmV4dCA9IHRydWUsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfcG9zLFxuICAgICAgX3RhZyAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfcmVzdWx0LFxuICAgICAgX2FuY2hvciAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICB0ZXJtaW5hdG9yLFxuICAgICAgaXNQYWlyLFxuICAgICAgaXNFeHBsaWNpdFBhaXIsXG4gICAgICBpc01hcHBpbmcsXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCLyogWyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDVEOy8qIF0gKi9cbiAgICBpc01hcHBpbmcgPSBmYWxzZTtcbiAgICBfcmVzdWx0ID0gW107XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4N0IvKiB7ICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4N0Q7LyogfSAqL1xuICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICBzdGF0ZS5raW5kID0gaXNNYXBwaW5nID8gJ21hcHBpbmcnIDogJ3NlcXVlbmNlJztcbiAgICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFyZWFkTmV4dCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ21pc3NlZCBjb21tYSBiZXR3ZWVuIGZsb3cgY29sbGVjdGlvbiBlbnRyaWVzJyk7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIC8vIFwiZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMgY2FuIG5ldmVyIGJlIGNvbXBsZXRlbHkgZW1wdHlcIiwgYXMgcGVyIFlBTUwgMS4yLCBzZWN0aW9uIDcuNFxuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgXCJleHBlY3RlZCB0aGUgbm9kZSBjb250ZW50LCBidXQgZm91bmQgJywnXCIpO1xuICAgIH1cblxuICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gZmFsc2U7XG5cbiAgICBpZiAoY2ggPT09IDB4M0YvKiA/ICovKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IHRydWU7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuICAgIF9saW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgX3BvcyA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKGlzRXhwbGljaXRQYWlyIHx8IHN0YXRlLmxpbmUgPT09IF9saW5lKSAmJiBjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGlzUGFpciA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXBwaW5nKSB7XG4gICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfbGluZSwgX2xpbmVTdGFydCwgX3Bvcyk7XG4gICAgfSBlbHNlIGlmIChpc1BhaXIpIHtcbiAgICAgIF9yZXN1bHQucHVzaChzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBudWxsLCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfbGluZSwgX2xpbmVTdGFydCwgX3BvcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0LnB1c2goa2V5Tm9kZSk7XG4gICAgfVxuXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJDLyogLCAqLykge1xuICAgICAgcmVhZE5leHQgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFkTmV4dCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbicpO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGZvbGRpbmcsXG4gICAgICBjaG9tcGluZyAgICAgICA9IENIT01QSU5HX0NMSVAsXG4gICAgICBkaWRSZWFkQ29udGVudCA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSBmYWxzZSxcbiAgICAgIHRleHRJbmRlbnQgICAgID0gbm9kZUluZGVudCxcbiAgICAgIGVtcHR5TGluZXMgICAgID0gMCxcbiAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2UsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg3Qy8qIHwgKi8pIHtcbiAgICBmb2xkaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4M0UvKiA+ICovKSB7XG4gICAgZm9sZGluZyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkIvKiArICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgICAgaWYgKENIT01QSU5HX0NMSVAgPT09IGNob21waW5nKSB7XG4gICAgICAgIGNob21waW5nID0gKGNoID09PSAweDJCLyogKyAqLykgPyBDSE9NUElOR19LRUVQIDogQ0hPTVBJTkdfU1RSSVA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGEgY2hvbXBpbmcgbW9kZSBpZGVudGlmaWVyJyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCh0bXAgPSBmcm9tRGVjaW1hbENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICBpZiAodG1wID09PSAwKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgZXhwbGljaXQgaW5kZW50YXRpb24gd2lkdGggb2YgYSBibG9jayBzY2FsYXI7IGl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gb25lJyk7XG4gICAgICB9IGVsc2UgaWYgKCFkZXRlY3RlZEluZGVudCkge1xuICAgICAgICB0ZXh0SW5kZW50ID0gbm9kZUluZGVudCArIHRtcCAtIDE7XG4gICAgICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpO1xuXG4gICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoKCFkZXRlY3RlZEluZGVudCB8fCBzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkgJiZcbiAgICAgICAgICAgKGNoID09PSAweDIwLyogU3BhY2UgKi8pKSB7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKCFkZXRlY3RlZEluZGVudCAmJiBzdGF0ZS5saW5lSW5kZW50ID4gdGV4dEluZGVudCkge1xuICAgICAgdGV4dEluZGVudCA9IHN0YXRlLmxpbmVJbmRlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGVtcHR5TGluZXMrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEVuZCBvZiB0aGUgc2NhbGFyLlxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkge1xuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBjaG9tcGluZy5cbiAgICAgIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfS0VFUCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfQ0xJUCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHRoZSBzY2FsYXIgaXMgbm90IGVtcHR5LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCcmVhayB0aGlzIGB3aGlsZWAgY3ljbGUgYW5kIGdvIHRvIHRoZSBmdW5jaXRvbidzIGVwaWxvZ3VlLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRm9sZGVkIHN0eWxlOiB1c2UgZmFuY3kgcnVsZXMgdG8gaGFuZGxlIGxpbmUgYnJlYWtzLlxuICAgIGlmIChmb2xkaW5nKSB7XG5cbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY29udGVudCBsaW5lIChjZi4gRXhhbXBsZSA4LjEpXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG5cbiAgICAgIC8vIEVuZCBvZiBtb3JlLWluZGVudGVkIGJsb2NrLlxuICAgICAgfSBlbHNlIGlmIChhdE1vcmVJbmRlbnRlZCkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpO1xuXG4gICAgICAvLyBKdXN0IG9uZSBsaW5lIGJyZWFrIC0gcGVyY2VpdmUgYXMgdGhlIHNhbWUgbGluZS5cbiAgICAgIH0gZWxzZSBpZiAoZW1wdHlMaW5lcyA9PT0gMCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHdlIGhhdmUgYWxyZWFkeSByZWFkIHNvbWUgc2NhbGFyIGNvbnRlbnQuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAvLyBTZXZlcmFsIGxpbmUgYnJlYWtzIC0gcGVyY2VpdmUgYXMgZGlmZmVyZW50IGxpbmVzLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfVxuXG4gICAgLy8gTGl0ZXJhbCBzdHlsZToganVzdCBhZGQgZXhhY3QgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIGJldHdlZW4gY29udGVudCBsaW5lcy5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gS2VlcCBhbGwgbGluZSBicmVha3MgZXhjZXB0IHRoZSBoZWFkZXIgbGluZSBicmVhay5cbiAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG4gICAgfVxuXG4gICAgZGlkUmVhZENvbnRlbnQgPSB0cnVlO1xuICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICBlbXB0eUxpbmVzID0gMDtcbiAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgX2xpbmUsXG4gICAgICBfdGFnICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgPSBbXSxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGRldGVjdGVkICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgLy8gdGhlcmUgaXMgYSBsZWFkaW5nIHRhYiBiZWZvcmUgdGhpcyB0b2tlbiwgc28gaXQgY2FuJ3QgYmUgYSBibG9jayBzZXF1ZW5jZS9tYXBwaW5nO1xuICAvLyBpdCBjYW4gc3RpbGwgYmUgZmxvdyBzZXF1ZW5jZS9tYXBwaW5nIG9yIGEgc2NhbGFyXG4gIGlmIChzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXRlLmZpcnN0VGFiSW5MaW5lO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhYiBjaGFyYWN0ZXJzIG11c3Qgbm90IGJlIHVzZWQgaW4gaW5kZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDB4MkQvKiAtICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoIWlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDw9IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgX3Jlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBfcmVzdWx0LnB1c2goc3RhdGUucmVzdWx0KTtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIHNlcXVlbmNlIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnc2VxdWVuY2UnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBub2RlSW5kZW50LCBmbG93SW5kZW50KSB7XG4gIHZhciBmb2xsb3dpbmcsXG4gICAgICBhbGxvd0NvbXBhY3QsXG4gICAgICBfbGluZSxcbiAgICAgIF9rZXlMaW5lLFxuICAgICAgX2tleUxpbmVTdGFydCxcbiAgICAgIF9rZXlQb3MsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgICAgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICAgICAgPSB7fSxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBrZXlUYWcgICAgICAgID0gbnVsbCxcbiAgICAgIGtleU5vZGUgICAgICAgPSBudWxsLFxuICAgICAgdmFsdWVOb2RlICAgICA9IG51bGwsXG4gICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZCAgICAgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICAvLyB0aGVyZSBpcyBhIGxlYWRpbmcgdGFiIGJlZm9yZSB0aGlzIHRva2VuLCBzbyBpdCBjYW4ndCBiZSBhIGJsb2NrIHNlcXVlbmNlL21hcHBpbmc7XG4gIC8vIGl0IGNhbiBzdGlsbCBiZSBmbG93IHNlcXVlbmNlL21hcHBpbmcgb3IgYSBzY2FsYXJcbiAgaWYgKHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmICghYXRFeHBsaWNpdEtleSAmJiBzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uID0gc3RhdGUuZmlyc3RUYWJJbkxpbmU7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFiIGNoYXJhY3RlcnMgbXVzdCBub3QgYmUgdXNlZCBpbiBpbmRlbnRhdGlvbicpO1xuICAgIH1cblxuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cblxuICAgIC8vXG4gICAgLy8gRXhwbGljaXQgbm90YXRpb24gY2FzZS4gVGhlcmUgYXJlIHR3byBzZXBhcmF0ZSBibG9ja3M6XG4gICAgLy8gZmlyc3QgZm9yIHRoZSBrZXkgKGRlbm90ZWQgYnkgXCI/XCIpIGFuZCBzZWNvbmQgZm9yIHRoZSB2YWx1ZSAoZGVub3RlZCBieSBcIjpcIilcbiAgICAvL1xuICAgIGlmICgoY2ggPT09IDB4M0YvKiA/ICovIHx8IGNoID09PSAweDNBLyogOiAqLykgJiYgaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcblxuICAgICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2UgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgLy8gaS5lLiAweDNBLyogOiAqLyA9PT0gY2hhcmFjdGVyIGFmdGVyIHRoZSBleHBsaWNpdCBrZXkuXG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZDsgb3IgZm9sbG93ZWQgYnkgYSBub24tdGFidWxhdGVkIGVtcHR5IGxpbmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nO1xuXG4gICAgLy9cbiAgICAvLyBJbXBsaWNpdCBub3RhdGlvbiBjYXNlLiBGbG93LXN0eWxlIG5vZGUgYXMgdGhlIGtleSBmaXJzdCwgdGhlbiBcIjpcIiwgYW5kIHRoZSB2YWx1ZS5cbiAgICAvL1xuICAgIH0gZWxzZSB7XG4gICAgICBfa2V5TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICBfa2V5TGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgX2tleVBvcyA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgICBpZiAoIWNvbXBvc2VOb2RlKHN0YXRlLCBmbG93SW5kZW50LCBDT05URVhUX0ZMT1dfT1VULCBmYWxzZSwgdHJ1ZSkpIHtcbiAgICAgICAgLy8gTmVpdGhlciBpbXBsaWNpdCBub3IgZXhwbGljaXQgbm90YXRpb24uXG4gICAgICAgIC8vIFJlYWRpbmcgaXMgZG9uZS4gR28gdG8gdGhlIGVwaWxvZ3VlLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgYWxsb3dDb21wYWN0ID0gZmFsc2U7XG4gICAgICAgICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYW4gaW1wbGljaXQgbWFwcGluZyBwYWlyOyBhIGNvbG9uIGlzIG1pc3NlZCcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXknKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQ29tbW9uIHJlYWRpbmcgY29kZSBmb3IgYm90aCBleHBsaWNpdCBhbmQgaW1wbGljaXQgbm90YXRpb25zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSB7XG4gICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBfa2V5TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICAgIF9rZXlMaW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICAgIF9rZXlQb3MgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX09VVCwgdHJ1ZSwgYWxsb3dDb21wYWN0KSkge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBtYXBwaW5nIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gRXBpbG9ndWUuXG4gIC8vXG5cbiAgLy8gU3BlY2lhbCBjYXNlOiBsYXN0IG1hcHBpbmcncyBub2RlIGNvbnRhaW5zIG9ubHkgdGhlIGtleSBpbiBleHBsaWNpdCBub3RhdGlvbi5cbiAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoZSByZXN1bHRpbmcgbWFwcGluZy5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnbWFwcGluZyc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBkZXRlY3RlZDtcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBpc1ZlcmJhdGltID0gZmFsc2UsXG4gICAgICBpc05hbWVkICAgID0gZmFsc2UsXG4gICAgICB0YWdIYW5kbGUsXG4gICAgICB0YWdOYW1lLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjEvKiAhICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhIHRhZyBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgzQy8qIDwgKi8pIHtcbiAgICBpc1ZlcmJhdGltID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICB0YWdIYW5kbGUgPSAnISEnO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2Uge1xuICAgIHRhZ0hhbmRsZSA9ICchJztcbiAgfVxuXG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgY2ggIT09IDB4M0UvKiA+ICovKTtcblxuICAgIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWcnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICAgICAgaWYgKCFpc05hbWVkKSB7XG4gICAgICAgICAgdGFnSGFuZGxlID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uIC0gMSwgc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QodGFnSGFuZGxlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWVkIHRhZyBoYW5kbGUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNOYW1lZCA9IHRydWU7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUy50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBmbG93IGluZGljYXRvciBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ05hbWUgJiYgIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHRhZ05hbWUpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVyczogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0YWdOYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KHRhZ05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIG5hbWUgaXMgbWFsZm9ybWVkOiAnICsgdGFnTmFtZSk7XG4gIH1cblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIHN0YXRlLnRhZyA9IHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkkMS5jYWxsKHN0YXRlLnRhZ01hcCwgdGFnSGFuZGxlKSkge1xuICAgIHN0YXRlLnRhZyA9IHN0YXRlLnRhZ01hcFt0YWdIYW5kbGVdICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEnKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEhJykge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNi8qICYgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MkEvKiAqICovKSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIV9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwoc3RhdGUuYW5jaG9yTWFwLCBhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSwgLy8gMTogdGhpcz5wYXJlbnQsIDA6IHRoaXM9cGFyZW50LCAtMTogdGhpczxwYXJlbnRcbiAgICAgIGF0TmV3TGluZSAgPSBmYWxzZSxcbiAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgIHR5cGVJbmRleCxcbiAgICAgIHR5cGVRdWFudGl0eSxcbiAgICAgIHR5cGVMaXN0LFxuICAgICAgdHlwZSxcbiAgICAgIGZsb3dJbmRlbnQsXG4gICAgICBibG9ja0luZGVudDtcblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignb3BlbicsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnRhZyAgICA9IG51bGw7XG4gIHN0YXRlLmFuY2hvciA9IG51bGw7XG4gIHN0YXRlLmtpbmQgICA9IG51bGw7XG4gIHN0YXRlLnJlc3VsdCA9IG51bGw7XG5cbiAgYWxsb3dCbG9ja1N0eWxlcyA9IGFsbG93QmxvY2tTY2FsYXJzID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zID1cbiAgICBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQgfHxcbiAgICBDT05URVhUX0JMT0NLX0lOICA9PT0gbm9kZUNvbnRleHQ7XG5cbiAgaWYgKGFsbG93VG9TZWVrKSB7XG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSkge1xuICAgIHdoaWxlIChyZWFkVGFnUHJvcGVydHkoc3RhdGUpIHx8IHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYWxsb3dCbG9ja1N0eWxlcztcblxuICAgICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMpIHtcbiAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhdE5ld0xpbmUgfHwgYWxsb3dDb21wYWN0O1xuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSB8fCBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICBpZiAoQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCB8fCBDT05URVhUX0ZMT1dfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudCArIDE7XG4gICAgfVxuXG4gICAgYmxvY2tJbmRlbnQgPSBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydDtcblxuICAgIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICAgIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiZcbiAgICAgICAgICAocmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KSB8fFxuICAgICAgICAgICByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBibG9ja0luZGVudCwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoYWxsb3dCbG9ja1NjYWxhcnMgJiYgcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkgfHxcbiAgICAgICAgICAgIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpIHx8XG4gICAgICAgICAgICByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVhZEFsaWFzKHN0YXRlKSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCB8fCBzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhbGlhcyBub2RlIHNob3VsZCBub3QgaGF2ZSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluZGVudFN0YXR1cyA9PT0gMCkge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBibG9jayBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgdG8gaGF2ZSBzYW1lIGluZGVudGF0aW9uIGxldmVsIGFzIHRoZSBwYXJlbnQuXG4gICAgICAvLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI3OTk3ODRcbiAgICAgIGhhc0NvbnRlbnQgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoc3RhdGUudGFnID09PSAnPycpIHtcbiAgICAvLyBJbXBsaWNpdCByZXNvbHZpbmcgaXMgbm90IGFsbG93ZWQgZm9yIG5vbi1zY2FsYXIgdHlwZXMsIGFuZCAnPydcbiAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXV0b21hdGljYWxseSBhc3NpZ25lZCB0byBwbGFpbiBzY2FsYXJzLlxuICAgIC8vXG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIGNoZWNrIGtpbmQgY29uZm9ybWl0eSBpbiBjYXNlIHVzZXIgZXhwbGljaXRseSBhc3NpZ25zICc/J1xuICAgIC8vIHRhZywgZm9yIGV4YW1wbGUgbGlrZSB0aGlzOiBcIiE8Pz4gWzBdXCJcbiAgICAvL1xuICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgc3RhdGUua2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPD8+IHRhZzsgaXQgc2hvdWxkIGJlIFwic2NhbGFyXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbdHlwZUluZGV4XTtcblxuICAgICAgaWYgKHR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQpO1xuICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzdGF0ZS50YWcgIT09ICchJykge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkkMS5jYWxsKHN0YXRlLnR5cGVNYXBbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXSwgc3RhdGUudGFnKSkge1xuICAgICAgdHlwZSA9IHN0YXRlLnR5cGVNYXBbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXVtzdGF0ZS50YWddO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb29raW5nIGZvciBtdWx0aSB0eXBlXG4gICAgICB0eXBlID0gbnVsbDtcbiAgICAgIHR5cGVMaXN0ID0gc3RhdGUudHlwZU1hcC5tdWx0aVtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddO1xuXG4gICAgICBmb3IgKHR5cGVJbmRleCA9IDAsIHR5cGVRdWFudGl0eSA9IHR5cGVMaXN0Lmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgICBpZiAoc3RhdGUudGFnLnNsaWNlKDAsIHR5cGVMaXN0W3R5cGVJbmRleF0udGFnLmxlbmd0aCkgPT09IHR5cGVMaXN0W3R5cGVJbmRleF0udGFnKSB7XG4gICAgICAgICAgdHlwZSA9IHR5cGVMaXN0W3R5cGVJbmRleF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIHRhZyAhPCcgKyBzdGF0ZS50YWcgKyAnPicpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgdHlwZS5raW5kICE9PSBzdGF0ZS5raW5kKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITwnICsgc3RhdGUudGFnICsgJz4gdGFnOyBpdCBzaG91bGQgYmUgXCInICsgdHlwZS5raW5kICsgJ1wiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgIH1cblxuICAgIGlmICghdHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCwgc3RhdGUudGFnKSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgcmVzb2x2ZSBhIG5vZGUgd2l0aCAhPCcgKyBzdGF0ZS50YWcgKyAnPiBleHBsaWNpdCB0YWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0LCBzdGF0ZS50YWcpO1xuICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignY2xvc2UnLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnRhZyAhPT0gbnVsbCB8fCAgc3RhdGUuYW5jaG9yICE9PSBudWxsIHx8IGhhc0NvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHJlYWREb2N1bWVudChzdGF0ZSkge1xuICB2YXIgZG9jdW1lbnRTdGFydCA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgX3Bvc2l0aW9uLFxuICAgICAgZGlyZWN0aXZlTmFtZSxcbiAgICAgIGRpcmVjdGl2ZUFyZ3MsXG4gICAgICBoYXNEaXJlY3RpdmVzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBzdGF0ZS52ZXJzaW9uID0gbnVsbDtcbiAgc3RhdGUuY2hlY2tMaW5lQnJlYWtzID0gc3RhdGUubGVnYWN5O1xuICBzdGF0ZS50YWdNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdGF0ZS5hbmNob3JNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiAwIHx8IGNoICE9PSAweDI1LyogJSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgZGlyZWN0aXZlTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgIGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICAgIGlmIChkaXJlY3RpdmVOYW1lLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmUgbmFtZSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gb25lIGNoYXJhY3RlciBpbiBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfRU9MKGNoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkgYnJlYWs7XG5cbiAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RpdmVBcmdzLnB1c2goc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbikpO1xuICAgIH1cblxuICAgIGlmIChjaCAhPT0gMCkgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChkaXJlY3RpdmVIYW5kbGVycywgZGlyZWN0aXZlTmFtZSkpIHtcbiAgICAgIGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZU5hbWVdKHN0YXRlLCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5rbm93biBkb2N1bWVudCBkaXJlY3RpdmUgXCInICsgZGlyZWN0aXZlTmFtZSArICdcIicpO1xuICAgIH1cbiAgfVxuXG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gMCAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgICAgID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDIpID09PSAweDJELyogLSAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBjb21wb3NlTm9kZShzdGF0ZSwgc3RhdGUubGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUuY2hlY2tMaW5lQnJlYWtzICYmXG4gICAgICBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUy50ZXN0KHN0YXRlLmlucHV0LnNsaWNlKGRvY3VtZW50U3RhcnQsIHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdub24tQVNDSUkgbGluZSBicmVha3MgYXJlIGludGVycHJldGVkIGFzIGNvbnRlbnQnKTtcbiAgfVxuXG4gIHN0YXRlLmRvY3VtZW50cy5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuXG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDJFLyogLiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2VuZCBvZiB0aGUgc3RyZWFtIG9yIGEgZG9jdW1lbnQgc2VwYXJhdG9yIGlzIGV4cGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcblxuICAgIC8vIEFkZCB0YWlsaW5nIGBcXG5gIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwQS8qIExGICovICYmXG4gICAgICAgIGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEQvKiBDUiAqLykge1xuICAgICAgaW5wdXQgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgQk9NXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgdmFyIG51bGxwb3MgPSBpbnB1dC5pbmRleE9mKCdcXDAnKTtcblxuICBpZiAobnVsbHBvcyAhPT0gLTEpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiA9IG51bGxwb3M7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ251bGwgYnl0ZSBpcyBub3QgYWxsb3dlZCBpbiBpbnB1dCcpO1xuICB9XG5cbiAgLy8gVXNlIDAgYXMgc3RyaW5nIHRlcm1pbmF0b3IuIFRoYXQgc2lnbmlmaWNhbnRseSBzaW1wbGlmaWVzIGJvdW5kcyBjaGVjay5cbiAgc3RhdGUuaW5wdXQgKz0gJ1xcMCc7XG5cbiAgd2hpbGUgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICBzdGF0ZS5saW5lSW5kZW50ICs9IDE7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHJlYWREb2N1bWVudChzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuZG9jdW1lbnRzO1xufVxuXG5cbmZ1bmN0aW9uIGxvYWRBbGwkMShpbnB1dCwgaXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgaWYgKGl0ZXJhdG9yICE9PSBudWxsICYmIHR5cGVvZiBpdGVyYXRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGl0ZXJhdG9yO1xuICAgIGl0ZXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKTtcblxuICBpZiAodHlwZW9mIGl0ZXJhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50cztcbiAgfVxuXG4gIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZG9jdW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBpdGVyYXRvcihkb2N1bWVudHNbaW5kZXhdKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWQkMShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50c1swXTtcbiAgfVxuICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZScpO1xufVxuXG5cbnZhciBsb2FkQWxsXzEgPSBsb2FkQWxsJDE7XG52YXIgbG9hZF8xICAgID0gbG9hZCQxO1xuXG52YXIgbG9hZGVyID0ge1xuXHRsb2FkQWxsOiBsb2FkQWxsXzEsXG5cdGxvYWQ6IGxvYWRfMVxufTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSovXG5cblxuXG5cblxudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIENIQVJfQk9NICAgICAgICAgICAgICAgICAgPSAweEZFRkY7XG52YXIgQ0hBUl9UQUIgICAgICAgICAgICAgICAgICA9IDB4MDk7IC8qIFRhYiAqL1xudmFyIENIQVJfTElORV9GRUVEICAgICAgICAgICAgPSAweDBBOyAvKiBMRiAqL1xudmFyIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgPSAweDBEOyAvKiBDUiAqL1xudmFyIENIQVJfU1BBQ0UgICAgICAgICAgICAgICAgPSAweDIwOyAvKiBTcGFjZSAqL1xudmFyIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPSAweDIxOyAvKiAhICovXG52YXIgQ0hBUl9ET1VCTEVfUVVPVEUgICAgICAgICA9IDB4MjI7IC8qIFwiICovXG52YXIgQ0hBUl9TSEFSUCAgICAgICAgICAgICAgICA9IDB4MjM7IC8qICMgKi9cbnZhciBDSEFSX1BFUkNFTlQgICAgICAgICAgICAgID0gMHgyNTsgLyogJSAqL1xudmFyIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgPSAweDI2OyAvKiAmICovXG52YXIgQ0hBUl9TSU5HTEVfUVVPVEUgICAgICAgICA9IDB4Mjc7IC8qICcgKi9cbnZhciBDSEFSX0FTVEVSSVNLICAgICAgICAgICAgID0gMHgyQTsgLyogKiAqL1xudmFyIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPSAweDJDOyAvKiAsICovXG52YXIgQ0hBUl9NSU5VUyAgICAgICAgICAgICAgICA9IDB4MkQ7IC8qIC0gKi9cbnZhciBDSEFSX0NPTE9OICAgICAgICAgICAgICAgID0gMHgzQTsgLyogOiAqL1xudmFyIENIQVJfRVFVQUxTICAgICAgICAgICAgICAgPSAweDNEOyAvKiA9ICovXG52YXIgQ0hBUl9HUkVBVEVSX1RIQU4gICAgICAgICA9IDB4M0U7IC8qID4gKi9cbnZhciBDSEFSX1FVRVNUSU9OICAgICAgICAgICAgID0gMHgzRjsgLyogPyAqL1xudmFyIENIQVJfQ09NTUVSQ0lBTF9BVCAgICAgICAgPSAweDQwOyAvKiBAICovXG52YXIgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICA9IDB4NUI7IC8qIFsgKi9cbnZhciBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID0gMHg1RDsgLyogXSAqL1xudmFyIENIQVJfR1JBVkVfQUNDRU5UICAgICAgICAgPSAweDYwOyAvKiBgICovXG52YXIgQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQgICA9IDB4N0I7IC8qIHsgKi9cbnZhciBDSEFSX1ZFUlRJQ0FMX0xJTkUgICAgICAgID0gMHg3QzsgLyogfCAqL1xudmFyIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAgPSAweDdEOyAvKiB9ICovXG5cbnZhciBFU0NBUEVfU0VRVUVOQ0VTID0ge307XG5cbkVTQ0FQRV9TRVFVRU5DRVNbMHgwMF0gICA9ICdcXFxcMCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDddICAgPSAnXFxcXGEnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA4XSAgID0gJ1xcXFxiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOV0gICA9ICdcXFxcdCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEFdICAgPSAnXFxcXG4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBCXSAgID0gJ1xcXFx2JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQ10gICA9ICdcXFxcZic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MERdICAgPSAnXFxcXHInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDFCXSAgID0gJ1xcXFxlJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMl0gICA9ICdcXFxcXCInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDVDXSAgID0gJ1xcXFxcXFxcJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg4NV0gICA9ICdcXFxcTic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4QTBdICAgPSAnXFxcXF8nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjhdID0gJ1xcXFxMJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XG5cbnZhciBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWCA9IFtcbiAgJ3knLCAnWScsICd5ZXMnLCAnWWVzJywgJ1lFUycsICdvbicsICdPbicsICdPTicsXG4gICduJywgJ04nLCAnbm8nLCAnTm8nLCAnTk8nLCAnb2ZmJywgJ09mZicsICdPRkYnXG5dO1xuXG52YXIgREVQUkVDQVRFRF9CQVNFNjBfU1lOVEFYID0gL15bLStdP1swLTlfXSsoPzo6WzAtOV9dKykrKD86XFwuWzAtOV9dKik/JC87XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZU1hcChzY2hlbWEsIG1hcCkge1xuICB2YXIgcmVzdWx0LCBrZXlzLCBpbmRleCwgbGVuZ3RoLCB0YWcsIHN0eWxlLCB0eXBlO1xuXG4gIGlmIChtYXAgPT09IG51bGwpIHJldHVybiB7fTtcblxuICByZXN1bHQgPSB7fTtcbiAga2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHRhZyA9IGtleXNbaW5kZXhdO1xuICAgIHN0eWxlID0gU3RyaW5nKG1hcFt0YWddKTtcblxuICAgIGlmICh0YWcuc2xpY2UoMCwgMikgPT09ICchIScpIHtcbiAgICAgIHRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnLnNsaWNlKDIpO1xuICAgIH1cbiAgICB0eXBlID0gc2NoZW1hLmNvbXBpbGVkVHlwZU1hcFsnZmFsbGJhY2snXVt0YWddO1xuXG4gICAgaWYgKHR5cGUgJiYgX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5zdHlsZUFsaWFzZXMsIHN0eWxlKSkge1xuICAgICAgc3R5bGUgPSB0eXBlLnN0eWxlQWxpYXNlc1tzdHlsZV07XG4gICAgfVxuXG4gICAgcmVzdWx0W3RhZ10gPSBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUhleChjaGFyYWN0ZXIpIHtcbiAgdmFyIHN0cmluZywgaGFuZGxlLCBsZW5ndGg7XG5cbiAgc3RyaW5nID0gY2hhcmFjdGVyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gIGlmIChjaGFyYWN0ZXIgPD0gMHhGRikge1xuICAgIGhhbmRsZSA9ICd4JztcbiAgICBsZW5ndGggPSAyO1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkYpIHtcbiAgICBoYW5kbGUgPSAndSc7XG4gICAgbGVuZ3RoID0gNDtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGRkZGRikge1xuICAgIGhhbmRsZSA9ICdVJztcbiAgICBsZW5ndGggPSA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cblxudmFyIFFVT1RJTkdfVFlQRV9TSU5HTEUgPSAxLFxuICAgIFFVT1RJTkdfVFlQRV9ET1VCTEUgPSAyO1xuXG5mdW5jdGlvbiBTdGF0ZShvcHRpb25zKSB7XG4gIHRoaXMuc2NoZW1hICAgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IF9kZWZhdWx0O1xuICB0aGlzLmluZGVudCAgICAgICAgPSBNYXRoLm1heCgxLCAob3B0aW9uc1snaW5kZW50J10gfHwgMikpO1xuICB0aGlzLm5vQXJyYXlJbmRlbnQgPSBvcHRpb25zWydub0FycmF5SW5kZW50J10gfHwgZmFsc2U7XG4gIHRoaXMuc2tpcEludmFsaWQgICA9IG9wdGlvbnNbJ3NraXBJbnZhbGlkJ10gfHwgZmFsc2U7XG4gIHRoaXMuZmxvd0xldmVsICAgICA9IChjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ10pO1xuICB0aGlzLnN0eWxlTWFwICAgICAgPSBjb21waWxlU3R5bGVNYXAodGhpcy5zY2hlbWEsIG9wdGlvbnNbJ3N0eWxlcyddIHx8IG51bGwpO1xuICB0aGlzLnNvcnRLZXlzICAgICAgPSBvcHRpb25zWydzb3J0S2V5cyddIHx8IGZhbHNlO1xuICB0aGlzLmxpbmVXaWR0aCAgICAgPSBvcHRpb25zWydsaW5lV2lkdGgnXSB8fCA4MDtcbiAgdGhpcy5ub1JlZnMgICAgICAgID0gb3B0aW9uc1snbm9SZWZzJ10gfHwgZmFsc2U7XG4gIHRoaXMubm9Db21wYXRNb2RlICA9IG9wdGlvbnNbJ25vQ29tcGF0TW9kZSddIHx8IGZhbHNlO1xuICB0aGlzLmNvbmRlbnNlRmxvdyAgPSBvcHRpb25zWydjb25kZW5zZUZsb3cnXSB8fCBmYWxzZTtcbiAgdGhpcy5xdW90aW5nVHlwZSAgID0gb3B0aW9uc1sncXVvdGluZ1R5cGUnXSA9PT0gJ1wiJyA/IFFVT1RJTkdfVFlQRV9ET1VCTEUgOiBRVU9USU5HX1RZUEVfU0lOR0xFO1xuICB0aGlzLmZvcmNlUXVvdGVzICAgPSBvcHRpb25zWydmb3JjZVF1b3RlcyddIHx8IGZhbHNlO1xuICB0aGlzLnJlcGxhY2VyICAgICAgPSB0eXBlb2Ygb3B0aW9uc1sncmVwbGFjZXInXSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnNbJ3JlcGxhY2VyJ10gOiBudWxsO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMuZXhwbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkRXhwbGljaXQ7XG5cbiAgdGhpcy50YWcgPSBudWxsO1xuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIHRoaXMuZHVwbGljYXRlcyA9IFtdO1xuICB0aGlzLnVzZWREdXBsaWNhdGVzID0gbnVsbDtcbn1cblxuLy8gSW5kZW50cyBldmVyeSBsaW5lIGluIGEgc3RyaW5nLiBFbXB0eSBsaW5lcyAoXFxuIG9ubHkpIGFyZSBub3QgaW5kZW50ZWQuXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RyaW5nLCBzcGFjZXMpIHtcbiAgdmFyIGluZCA9IGNvbW1vbi5yZXBlYXQoJyAnLCBzcGFjZXMpLFxuICAgICAgcG9zaXRpb24gPSAwLFxuICAgICAgbmV4dCA9IC0xLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBsaW5lLFxuICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICBuZXh0ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIHBvc2l0aW9uKTtcbiAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24pO1xuICAgICAgcG9zaXRpb24gPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24sIG5leHQgKyAxKTtcbiAgICAgIHBvc2l0aW9uID0gbmV4dCArIDE7XG4gICAgfVxuXG4gICAgaWYgKGxpbmUubGVuZ3RoICYmIGxpbmUgIT09ICdcXG4nKSByZXN1bHQgKz0gaW5kO1xuXG4gICAgcmVzdWx0ICs9IGxpbmU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCkge1xuICByZXR1cm4gJ1xcbicgKyBjb21tb24ucmVwZWF0KCcgJywgc3RhdGUuaW5kZW50ICogbGV2ZWwpO1xufVxuXG5mdW5jdGlvbiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cikge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwgdHlwZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbaW5kZXhdO1xuXG4gICAgaWYgKHR5cGUucmVzb2x2ZShzdHIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFszM10gcy13aGl0ZSA6Oj0gcy1zcGFjZSB8IHMtdGFiXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoYykge1xuICByZXR1cm4gYyA9PT0gQ0hBUl9TUEFDRSB8fCBjID09PSBDSEFSX1RBQjtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgY2FuIGJlIHByaW50ZWQgd2l0aG91dCBlc2NhcGluZy5cbi8vIEZyb20gWUFNTCAxLjI6IFwiYW55IGFsbG93ZWQgY2hhcmFjdGVycyBrbm93biB0byBiZSBub24tcHJpbnRhYmxlXG4vLyBzaG91bGQgYWxzbyBiZSBlc2NhcGVkLiBbSG93ZXZlcixdIFRoaXMgaXNu4oCZdCBtYW5kYXRvcnlcIlxuLy8gRGVyaXZlZCBmcm9tIG5iLWNoYXIgLSBcXHQgLSAjeDg1IC0gI3hBMCAtICN4MjAyOCAtICN4MjAyOS5cbmZ1bmN0aW9uIGlzUHJpbnRhYmxlKGMpIHtcbiAgcmV0dXJuICAoMHgwMDAyMCA8PSBjICYmIGMgPD0gMHgwMDAwN0UpXG4gICAgICB8fCAoKDB4MDAwQTEgPD0gYyAmJiBjIDw9IDB4MDBEN0ZGKSAmJiBjICE9PSAweDIwMjggJiYgYyAhPT0gMHgyMDI5KVxuICAgICAgfHwgKCgweDBFMDAwIDw9IGMgJiYgYyA8PSAweDAwRkZGRCkgJiYgYyAhPT0gQ0hBUl9CT00pXG4gICAgICB8fCAgKDB4MTAwMDAgPD0gYyAmJiBjIDw9IDB4MTBGRkZGKTtcbn1cblxuLy8gWzM0XSBucy1jaGFyIDo6PSBuYi1jaGFyIC0gcy13aGl0ZVxuLy8gWzI3XSBuYi1jaGFyIDo6PSBjLXByaW50YWJsZSAtIGItY2hhciAtIGMtYnl0ZS1vcmRlci1tYXJrXG4vLyBbMjZdIGItY2hhciAgOjo9IGItbGluZS1mZWVkIHwgYi1jYXJyaWFnZS1yZXR1cm5cbi8vIEluY2x1ZGluZyBzLXdoaXRlIChmb3Igc29tZSByZWFzb24sIGV4YW1wbGVzIGRvZXNuJ3QgbWF0Y2ggc3BlY3MgaW4gdGhpcyBhc3BlY3QpXG4vLyBucy1jaGFyIDo6PSBjLXByaW50YWJsZSAtIGItbGluZS1mZWVkIC0gYi1jYXJyaWFnZS1yZXR1cm4gLSBjLWJ5dGUtb3JkZXItbWFya1xuZnVuY3Rpb24gaXNOc0NoYXJPcldoaXRlc3BhY2UoYykge1xuICByZXR1cm4gaXNQcmludGFibGUoYylcbiAgICAmJiBjICE9PSBDSEFSX0JPTVxuICAgIC8vIC0gYi1jaGFyXG4gICAgJiYgYyAhPT0gQ0hBUl9DQVJSSUFHRV9SRVRVUk5cbiAgICAmJiBjICE9PSBDSEFSX0xJTkVfRkVFRDtcbn1cblxuLy8gWzEyN10gIG5zLXBsYWluLXNhZmUoYykgOjo9IGMgPSBmbG93LW91dCAg4oeSIG5zLXBsYWluLXNhZmUtb3V0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZsb3ctaW4gICDih5IgbnMtcGxhaW4tc2FmZS1pblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBibG9jay1rZXkg4oeSIG5zLXBsYWluLXNhZmUtb3V0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZsb3cta2V5ICDih5IgbnMtcGxhaW4tc2FmZS1pblxuLy8gWzEyOF0gbnMtcGxhaW4tc2FmZS1vdXQgOjo9IG5zLWNoYXJcbi8vIFsxMjldICBucy1wbGFpbi1zYWZlLWluIDo6PSBucy1jaGFyIC0gYy1mbG93LWluZGljYXRvclxuLy8gWzEzMF0gIG5zLXBsYWluLWNoYXIoYykgOjo9ICAoIG5zLXBsYWluLXNhZmUoYykgLSDigJw64oCdIC0g4oCcI+KAnSApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICggLyogQW4gbnMtY2hhciBwcmVjZWRpbmcgKi8g4oCcI+KAnSApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgg4oCcOuKAnSAvKiBGb2xsb3dlZCBieSBhbiBucy1wbGFpbi1zYWZlKGMpICovIClcbmZ1bmN0aW9uIGlzUGxhaW5TYWZlKGMsIHByZXYsIGluYmxvY2spIHtcbiAgdmFyIGNJc05zQ2hhck9yV2hpdGVzcGFjZSA9IGlzTnNDaGFyT3JXaGl0ZXNwYWNlKGMpO1xuICB2YXIgY0lzTnNDaGFyID0gY0lzTnNDaGFyT3JXaGl0ZXNwYWNlICYmICFpc1doaXRlc3BhY2UoYyk7XG4gIHJldHVybiAoXG4gICAgLy8gbnMtcGxhaW4tc2FmZVxuICAgIGluYmxvY2sgPyAvLyBjID0gZmxvdy1pblxuICAgICAgY0lzTnNDaGFyT3JXaGl0ZXNwYWNlXG4gICAgICA6IGNJc05zQ2hhck9yV2hpdGVzcGFjZVxuICAgICAgICAvLyAtIGMtZmxvdy1pbmRpY2F0b3JcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICAgICAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVFxuICAgICAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICAgICAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVRcbiAgKVxuICAgIC8vIG5zLXBsYWluLWNoYXJcbiAgICAmJiBjICE9PSBDSEFSX1NIQVJQIC8vIGZhbHNlIG9uICcjJ1xuICAgICYmICEocHJldiA9PT0gQ0hBUl9DT0xPTiAmJiAhY0lzTnNDaGFyKSAvLyBmYWxzZSBvbiAnOiAnXG4gICAgfHwgKGlzTnNDaGFyT3JXaGl0ZXNwYWNlKHByZXYpICYmICFpc1doaXRlc3BhY2UocHJldikgJiYgYyA9PT0gQ0hBUl9TSEFSUCkgLy8gY2hhbmdlIHRvIHRydWUgb24gJ1teIF0jJ1xuICAgIHx8IChwcmV2ID09PSBDSEFSX0NPTE9OICYmIGNJc05zQ2hhcik7IC8vIGNoYW5nZSB0byB0cnVlIG9uICc6W14gXSdcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmVGaXJzdChjKSB7XG4gIC8vIFVzZXMgYSBzdWJzZXQgb2YgbnMtY2hhciAtIGMtaW5kaWNhdG9yXG4gIC8vIHdoZXJlIG5zLWNoYXIgPSBuYi1jaGFyIC0gcy13aGl0ZS5cbiAgLy8gTm8gc3VwcG9ydCBvZiAoICgg4oCcP+KAnSB8IOKAnDrigJ0gfCDigJwt4oCdICkgLyogRm9sbG93ZWQgYnkgYW4gbnMtcGxhaW4tc2FmZShjKSkgKi8gKSBwYXJ0XG4gIHJldHVybiBpc1ByaW50YWJsZShjKSAmJiBjICE9PSBDSEFSX0JPTVxuICAgICYmICFpc1doaXRlc3BhY2UoYykgLy8gLSBzLXdoaXRlXG4gICAgLy8gLSAoYy1pbmRpY2F0b3IgOjo9XG4gICAgLy8g4oCcLeKAnSB8IOKAnD/igJ0gfCDigJw64oCdIHwg4oCcLOKAnSB8IOKAnFvigJ0gfCDigJxd4oCdIHwg4oCce+KAnSB8IOKAnH3igJ1cbiAgICAmJiBjICE9PSBDSEFSX01JTlVTXG4gICAgJiYgYyAhPT0gQ0hBUl9RVUVTVElPTlxuICAgICYmIGMgIT09IENIQVJfQ09MT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTU1BXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gICAgLy8gfCDigJwj4oCdIHwg4oCcJuKAnSB8IOKAnCrigJ0gfCDigJwh4oCdIHwg4oCcfOKAnSB8IOKAnD3igJ0gfCDigJw+4oCdIHwg4oCcJ+KAnSB8IOKAnFwi4oCdXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUFxuICAgICYmIGMgIT09IENIQVJfQU1QRVJTQU5EXG4gICAgJiYgYyAhPT0gQ0hBUl9BU1RFUklTS1xuICAgICYmIGMgIT09IENIQVJfRVhDTEFNQVRJT05cbiAgICAmJiBjICE9PSBDSEFSX1ZFUlRJQ0FMX0xJTkVcbiAgICAmJiBjICE9PSBDSEFSX0VRVUFMU1xuICAgICYmIGMgIT09IENIQVJfR1JFQVRFUl9USEFOXG4gICAgJiYgYyAhPT0gQ0hBUl9TSU5HTEVfUVVPVEVcbiAgICAmJiBjICE9PSBDSEFSX0RPVUJMRV9RVU9URVxuICAgIC8vIHwg4oCcJeKAnSB8IOKAnEDigJ0gfCDigJxg4oCdKVxuICAgICYmIGMgIT09IENIQVJfUEVSQ0VOVFxuICAgICYmIGMgIT09IENIQVJfQ09NTUVSQ0lBTF9BVFxuICAgICYmIGMgIT09IENIQVJfR1JBVkVfQUNDRU5UO1xufVxuXG4vLyBTaW1wbGlmaWVkIHRlc3QgZm9yIHZhbHVlcyBhbGxvd2VkIGFzIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlTGFzdChjKSB7XG4gIC8vIGp1c3Qgbm90IHdoaXRlc3BhY2Ugb3IgY29sb24sIGl0IHdpbGwgYmUgY2hlY2tlZCB0byBiZSBwbGFpbiBjaGFyYWN0ZXIgbGF0ZXJcbiAgcmV0dXJuICFpc1doaXRlc3BhY2UoYykgJiYgYyAhPT0gQ0hBUl9DT0xPTjtcbn1cblxuLy8gU2FtZSBhcyAnc3RyaW5nJy5jb2RlUG9pbnRBdChwb3MpLCBidXQgd29ya3MgaW4gb2xkZXIgYnJvd3NlcnMuXG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHJpbmcsIHBvcykge1xuICB2YXIgZmlyc3QgPSBzdHJpbmcuY2hhckNvZGVBdChwb3MpLCBzZWNvbmQ7XG4gIGlmIChmaXJzdCA+PSAweEQ4MDAgJiYgZmlyc3QgPD0gMHhEQkZGICYmIHBvcyArIDEgPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgc2Vjb25kID0gc3RyaW5nLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuICAgICAgLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICByZXR1cm4gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpcnN0O1xufVxuXG4vLyBEZXRlcm1pbmVzIHdoZXRoZXIgYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGlzIHJlcXVpcmVkLlxuZnVuY3Rpb24gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpIHtcbiAgdmFyIGxlYWRpbmdTcGFjZVJlID0gL15cXG4qIC87XG4gIHJldHVybiBsZWFkaW5nU3BhY2VSZS50ZXN0KHN0cmluZyk7XG59XG5cbnZhciBTVFlMRV9QTEFJTiAgID0gMSxcbiAgICBTVFlMRV9TSU5HTEUgID0gMixcbiAgICBTVFlMRV9MSVRFUkFMID0gMyxcbiAgICBTVFlMRV9GT0xERUQgID0gNCxcbiAgICBTVFlMRV9ET1VCTEUgID0gNTtcblxuLy8gRGV0ZXJtaW5lcyB3aGljaCBzY2FsYXIgc3R5bGVzIGFyZSBwb3NzaWJsZSBhbmQgcmV0dXJucyB0aGUgcHJlZmVycmVkIHN0eWxlLlxuLy8gbGluZVdpZHRoID0gLTEgPT4gbm8gbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyLmxlbmd0aCA+IDAuXG4vLyBQb3N0LWNvbmRpdGlvbnM6XG4vLyAgICBTVFlMRV9QTEFJTiBvciBTVFlMRV9TSU5HTEUgPT4gbm8gXFxuIGFyZSBpbiB0aGUgc3RyaW5nLlxuLy8gICAgU1RZTEVfTElURVJBTCA9PiBubyBsaW5lcyBhcmUgc3VpdGFibGUgZm9yIGZvbGRpbmcgKG9yIGxpbmVXaWR0aCBpcyAtMSkuXG4vLyAgICBTVFlMRV9GT0xERUQgPT4gYSBsaW5lID4gbGluZVdpZHRoIGFuZCBjYW4gYmUgZm9sZGVkIChhbmQgbGluZVdpZHRoICE9IC0xKS5cbmZ1bmN0aW9uIGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIGluZGVudFBlckxldmVsLCBsaW5lV2lkdGgsXG4gIHRlc3RBbWJpZ3VvdXNUeXBlLCBxdW90aW5nVHlwZSwgZm9yY2VRdW90ZXMsIGluYmxvY2spIHtcblxuICB2YXIgaTtcbiAgdmFyIGNoYXIgPSAwO1xuICB2YXIgcHJldkNoYXIgPSBudWxsO1xuICB2YXIgaGFzTGluZUJyZWFrID0gZmFsc2U7XG4gIHZhciBoYXNGb2xkYWJsZUxpbmUgPSBmYWxzZTsgLy8gb25seSBjaGVja2VkIGlmIHNob3VsZFRyYWNrV2lkdGhcbiAgdmFyIHNob3VsZFRyYWNrV2lkdGggPSBsaW5lV2lkdGggIT09IC0xO1xuICB2YXIgcHJldmlvdXNMaW5lQnJlYWsgPSAtMTsgLy8gY291bnQgdGhlIGZpcnN0IGxpbmUgY29ycmVjdGx5XG4gIHZhciBwbGFpbiA9IGlzUGxhaW5TYWZlRmlyc3QoY29kZVBvaW50QXQoc3RyaW5nLCAwKSlcbiAgICAgICAgICAmJiBpc1BsYWluU2FmZUxhc3QoY29kZVBvaW50QXQoc3RyaW5nLCBzdHJpbmcubGVuZ3RoIC0gMSkpO1xuXG4gIGlmIChzaW5nbGVMaW5lT25seSB8fCBmb3JjZVF1b3Rlcykge1xuICAgIC8vIENhc2U6IG5vIGJsb2NrIHN0eWxlcy5cbiAgICAvLyBDaGVjayBmb3IgZGlzYWxsb3dlZCBjaGFyYWN0ZXJzIHRvIHJ1bGUgb3V0IHBsYWluIGFuZCBzaW5nbGUuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgICAgY2hhciA9IGNvZGVQb2ludEF0KHN0cmluZywgaSk7XG4gICAgICBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZDaGFyLCBpbmJsb2NrKTtcbiAgICAgIHByZXZDaGFyID0gY2hhcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZTogYmxvY2sgc3R5bGVzIHBlcm1pdHRlZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgY2hhciA+PSAweDEwMDAwID8gaSArPSAyIDogaSsrKSB7XG4gICAgICBjaGFyID0gY29kZVBvaW50QXQoc3RyaW5nLCBpKTtcbiAgICAgIGlmIChjaGFyID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgICBoYXNMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAvLyBDaGVjayBpZiBhbnkgbGluZSBjYW4gYmUgZm9sZGVkLlxuICAgICAgICBpZiAoc2hvdWxkVHJhY2tXaWR0aCkge1xuICAgICAgICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fFxuICAgICAgICAgICAgLy8gRm9sZGFibGUgbGluZSA9IHRvbyBsb25nLCBhbmQgbm90IG1vcmUtaW5kZW50ZWQuXG4gICAgICAgICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpO1xuICAgICAgICAgIHByZXZpb3VzTGluZUJyZWFrID0gaTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldkNoYXIsIGluYmxvY2spO1xuICAgICAgcHJldkNoYXIgPSBjaGFyO1xuICAgIH1cbiAgICAvLyBpbiBjYXNlIHRoZSBlbmQgaXMgbWlzc2luZyBhIFxcblxuICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fCAoc2hvdWxkVHJhY2tXaWR0aCAmJlxuICAgICAgKGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiZcbiAgICAgICBzdHJpbmdbcHJldmlvdXNMaW5lQnJlYWsgKyAxXSAhPT0gJyAnKSk7XG4gIH1cbiAgLy8gQWx0aG91Z2ggZXZlcnkgc3R5bGUgY2FuIHJlcHJlc2VudCBcXG4gd2l0aG91dCBlc2NhcGluZywgcHJlZmVyIGJsb2NrIHN0eWxlc1xuICAvLyBmb3IgbXVsdGlsaW5lLCBzaW5jZSB0aGV5J3JlIG1vcmUgcmVhZGFibGUgYW5kIHRoZXkgZG9uJ3QgYWRkIGVtcHR5IGxpbmVzLlxuICAvLyBBbHNvIHByZWZlciBmb2xkaW5nIGEgc3VwZXItbG9uZyBsaW5lLlxuICBpZiAoIWhhc0xpbmVCcmVhayAmJiAhaGFzRm9sZGFibGVMaW5lKSB7XG4gICAgLy8gU3RyaW5ncyBpbnRlcnByZXRhYmxlIGFzIGFub3RoZXIgdHlwZSBoYXZlIHRvIGJlIHF1b3RlZDtcbiAgICAvLyBlLmcuIHRoZSBzdHJpbmcgJ3RydWUnIHZzLiB0aGUgYm9vbGVhbiB0cnVlLlxuICAgIGlmIChwbGFpbiAmJiAhZm9yY2VRdW90ZXMgJiYgIXRlc3RBbWJpZ3VvdXNUeXBlKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBTVFlMRV9QTEFJTjtcbiAgICB9XG4gICAgcmV0dXJuIHF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gU1RZTEVfRE9VQkxFIDogU1RZTEVfU0lOR0xFO1xuICB9XG4gIC8vIEVkZ2UgY2FzZTogYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGNhbiBvbmx5IGhhdmUgb25lIGRpZ2l0LlxuICBpZiAoaW5kZW50UGVyTGV2ZWwgPiA5ICYmIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSkge1xuICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gIH1cbiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IGJsb2NrIHN0eWxlcyBhcmUgdmFsaWQuXG4gIC8vIFByZWZlciBsaXRlcmFsIHN0eWxlIHVubGVzcyB3ZSB3YW50IHRvIGZvbGQuXG4gIGlmICghZm9yY2VRdW90ZXMpIHtcbiAgICByZXR1cm4gaGFzRm9sZGFibGVMaW5lID8gU1RZTEVfRk9MREVEIDogU1RZTEVfTElURVJBTDtcbiAgfVxuICByZXR1cm4gcXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyBTVFlMRV9ET1VCTEUgOiBTVFlMRV9TSU5HTEU7XG59XG5cbi8vIE5vdGU6IGxpbmUgYnJlYWtpbmcvZm9sZGluZyBpcyBpbXBsZW1lbnRlZCBmb3Igb25seSB0aGUgZm9sZGVkIHN0eWxlLlxuLy8gTkIuIFdlIGRyb3AgdGhlIGxhc3QgdHJhaWxpbmcgbmV3bGluZSAoaWYgYW55KSBvZiBhIHJldHVybmVkIGJsb2NrIHNjYWxhclxuLy8gIHNpbmNlIHRoZSBkdW1wZXIgYWRkcyBpdHMgb3duIG5ld2xpbmUuIFRoaXMgYWx3YXlzIHdvcmtzOlxuLy8gICAg4oCiIE5vIGVuZGluZyBuZXdsaW5lID0+IHVuYWZmZWN0ZWQ7IGFscmVhZHkgdXNpbmcgc3RyaXAgXCItXCIgY2hvbXBpbmcuXG4vLyAgICDigKIgRW5kaW5nIG5ld2xpbmUgICAgPT4gcmVtb3ZlZCB0aGVuIHJlc3RvcmVkLlxuLy8gIEltcG9ydGFudGx5LCB0aGlzIGtlZXBzIHRoZSBcIitcIiBjaG9tcCBpbmRpY2F0b3IgZnJvbSBnYWluaW5nIGFuIGV4dHJhIGxpbmUuXG5mdW5jdGlvbiB3cml0ZVNjYWxhcihzdGF0ZSwgc3RyaW5nLCBsZXZlbCwgaXNrZXksIGluYmxvY2spIHtcbiAgc3RhdGUuZHVtcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBzdGF0ZS5xdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/ICdcIlwiJyA6IFwiJydcIjtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5ub0NvbXBhdE1vZGUpIHtcbiAgICAgIGlmIChERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWC5pbmRleE9mKHN0cmluZykgIT09IC0xIHx8IERFUFJFQ0FURURfQkFTRTYwX1NZTlRBWC50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gKCdcIicgKyBzdHJpbmcgKyAnXCInKSA6IChcIidcIiArIHN0cmluZyArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50ICogTWF0aC5tYXgoMSwgbGV2ZWwpOyAvLyBubyAwLWluZGVudCBzY2FsYXJzXG4gICAgLy8gQXMgaW5kZW50YXRpb24gZ2V0cyBkZWVwZXIsIGxldCB0aGUgd2lkdGggZGVjcmVhc2UgbW9ub3RvbmljYWxseVxuICAgIC8vIHRvIHRoZSBsb3dlciBib3VuZCBtaW4oc3RhdGUubGluZVdpZHRoLCA0MCkuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgaW1wbGllc1xuICAgIC8vICBzdGF0ZS5saW5lV2lkdGgg4omkIDQwICsgc3RhdGUuaW5kZW50OiB3aWR0aCBpcyBmaXhlZCBhdCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCA+IDQwICsgc3RhdGUuaW5kZW50OiB3aWR0aCBkZWNyZWFzZXMgdW50aWwgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vIFRoaXMgYmVoYXZlcyBiZXR0ZXIgdGhhbiBhIGNvbnN0YW50IG1pbmltdW0gd2lkdGggd2hpY2ggZGlzYWxsb3dzIG5hcnJvd2VyIG9wdGlvbnMsXG4gICAgLy8gb3IgYW4gaW5kZW50IHRocmVzaG9sZCB3aGljaCBjYXVzZXMgdGhlIHdpZHRoIHRvIHN1ZGRlbmx5IGluY3JlYXNlLlxuICAgIHZhciBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGggPT09IC0xXG4gICAgICA/IC0xIDogTWF0aC5tYXgoTWF0aC5taW4oc3RhdGUubGluZVdpZHRoLCA0MCksIHN0YXRlLmxpbmVXaWR0aCAtIGluZGVudCk7XG5cbiAgICAvLyBXaXRob3V0IGtub3dpbmcgaWYga2V5cyBhcmUgaW1wbGljaXQvZXhwbGljaXQsIGFzc3VtZSBpbXBsaWNpdCBmb3Igc2FmZXR5LlxuICAgIHZhciBzaW5nbGVMaW5lT25seSA9IGlza2V5XG4gICAgICAvLyBObyBibG9jayBzdHlsZXMgaW4gZmxvdyBtb2RlLlxuICAgICAgfHwgKHN0YXRlLmZsb3dMZXZlbCA+IC0xICYmIGxldmVsID49IHN0YXRlLmZsb3dMZXZlbCk7XG4gICAgZnVuY3Rpb24gdGVzdEFtYmlndWl0eShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cmluZyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBzdGF0ZS5pbmRlbnQsIGxpbmVXaWR0aCxcbiAgICAgIHRlc3RBbWJpZ3VpdHksIHN0YXRlLnF1b3RpbmdUeXBlLCBzdGF0ZS5mb3JjZVF1b3RlcyAmJiAhaXNrZXksIGluYmxvY2spKSB7XG5cbiAgICAgIGNhc2UgU1RZTEVfUExBSU46XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICBjYXNlIFNUWUxFX1NJTkdMRTpcbiAgICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyaW5nLnJlcGxhY2UoLycvZywgXCInJ1wiKSArIFwiJ1wiO1xuICAgICAgY2FzZSBTVFlMRV9MSVRFUkFMOlxuICAgICAgICByZXR1cm4gJ3wnICsgYmxvY2tIZWFkZXIoc3RyaW5nLCBzdGF0ZS5pbmRlbnQpXG4gICAgICAgICAgKyBkcm9wRW5kaW5nTmV3bGluZShpbmRlbnRTdHJpbmcoc3RyaW5nLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRk9MREVEOlxuICAgICAgICByZXR1cm4gJz4nICsgYmxvY2tIZWFkZXIoc3RyaW5nLCBzdGF0ZS5pbmRlbnQpXG4gICAgICAgICAgKyBkcm9wRW5kaW5nTmV3bGluZShpbmRlbnRTdHJpbmcoZm9sZFN0cmluZyhzdHJpbmcsIGxpbmVXaWR0aCksIGluZGVudCkpO1xuICAgICAgY2FzZSBTVFlMRV9ET1VCTEU6XG4gICAgICAgIHJldHVybiAnXCInICsgZXNjYXBlU3RyaW5nKHN0cmluZykgKyAnXCInO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignaW1wb3NzaWJsZSBlcnJvcjogaW52YWxpZCBzY2FsYXIgc3R5bGUnKTtcbiAgICB9XG4gIH0oKSk7XG59XG5cbi8vIFByZS1jb25kaXRpb25zOiBzdHJpbmcgaXMgdmFsaWQgZm9yIGEgYmxvY2sgc2NhbGFyLCAxIDw9IGluZGVudFBlckxldmVsIDw9IDkuXG5mdW5jdGlvbiBibG9ja0hlYWRlcihzdHJpbmcsIGluZGVudFBlckxldmVsKSB7XG4gIHZhciBpbmRlbnRJbmRpY2F0b3IgPSBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykgPyBTdHJpbmcoaW5kZW50UGVyTGV2ZWwpIDogJyc7XG5cbiAgLy8gbm90ZSB0aGUgc3BlY2lhbCBjYXNlOiB0aGUgc3RyaW5nICdcXG4nIGNvdW50cyBhcyBhIFwidHJhaWxpbmdcIiBlbXB0eSBsaW5lLlxuICB2YXIgY2xpcCA9ICAgICAgICAgIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuICB2YXIga2VlcCA9IGNsaXAgJiYgKHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMl0gPT09ICdcXG4nIHx8IHN0cmluZyA9PT0gJ1xcbicpO1xuICB2YXIgY2hvbXAgPSBrZWVwID8gJysnIDogKGNsaXAgPyAnJyA6ICctJyk7XG5cbiAgcmV0dXJuIGluZGVudEluZGljYXRvciArIGNob21wICsgJ1xcbic7XG59XG5cbi8vIChTZWUgdGhlIG5vdGUgZm9yIHdyaXRlU2NhbGFyLilcbmZ1bmN0aW9uIGRyb3BFbmRpbmdOZXdsaW5lKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbicgPyBzdHJpbmcuc2xpY2UoMCwgLTEpIDogc3RyaW5nO1xufVxuXG4vLyBOb3RlOiBhIGxvbmcgbGluZSB3aXRob3V0IGEgc3VpdGFibGUgYnJlYWsgcG9pbnQgd2lsbCBleGNlZWQgdGhlIHdpZHRoIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IGV2ZXJ5IGNoYXIgaW4gc3RyIGlzUHJpbnRhYmxlLCBzdHIubGVuZ3RoID4gMCwgd2lkdGggPiAwLlxuZnVuY3Rpb24gZm9sZFN0cmluZyhzdHJpbmcsIHdpZHRoKSB7XG4gIC8vIEluIGZvbGRlZCBzdHlsZSwgJGskIGNvbnNlY3V0aXZlIG5ld2xpbmVzIG91dHB1dCBhcyAkaysxJCBuZXdsaW5lc+KAlFxuICAvLyB1bmxlc3MgdGhleSdyZSBiZWZvcmUgb3IgYWZ0ZXIgYSBtb3JlLWluZGVudGVkIGxpbmUsIG9yIGF0IHRoZSB2ZXJ5XG4gIC8vIGJlZ2lubmluZyBvciBlbmQsIGluIHdoaWNoIGNhc2UgJGskIG1hcHMgdG8gJGskLlxuICAvLyBUaGVyZWZvcmUsIHBhcnNlIGVhY2ggY2h1bmsgYXMgbmV3bGluZShzKSBmb2xsb3dlZCBieSBhIGNvbnRlbnQgbGluZS5cbiAgdmFyIGxpbmVSZSA9IC8oXFxuKykoW15cXG5dKikvZztcblxuICAvLyBmaXJzdCBsaW5lIChwb3NzaWJseSBhbiBlbXB0eSBsaW5lKVxuICB2YXIgcmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dExGID0gc3RyaW5nLmluZGV4T2YoJ1xcbicpO1xuICAgIG5leHRMRiA9IG5leHRMRiAhPT0gLTEgPyBuZXh0TEYgOiBzdHJpbmcubGVuZ3RoO1xuICAgIGxpbmVSZS5sYXN0SW5kZXggPSBuZXh0TEY7XG4gICAgcmV0dXJuIGZvbGRMaW5lKHN0cmluZy5zbGljZSgwLCBuZXh0TEYpLCB3aWR0aCk7XG4gIH0oKSk7XG4gIC8vIElmIHdlIGhhdmVuJ3QgcmVhY2hlZCB0aGUgZmlyc3QgY29udGVudCBsaW5lIHlldCwgZG9uJ3QgYWRkIGFuIGV4dHJhIFxcbi5cbiAgdmFyIHByZXZNb3JlSW5kZW50ZWQgPSBzdHJpbmdbMF0gPT09ICdcXG4nIHx8IHN0cmluZ1swXSA9PT0gJyAnO1xuICB2YXIgbW9yZUluZGVudGVkO1xuXG4gIC8vIHJlc3Qgb2YgdGhlIGxpbmVzXG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IGxpbmVSZS5leGVjKHN0cmluZykpKSB7XG4gICAgdmFyIHByZWZpeCA9IG1hdGNoWzFdLCBsaW5lID0gbWF0Y2hbMl07XG4gICAgbW9yZUluZGVudGVkID0gKGxpbmVbMF0gPT09ICcgJyk7XG4gICAgcmVzdWx0ICs9IHByZWZpeFxuICAgICAgKyAoIXByZXZNb3JlSW5kZW50ZWQgJiYgIW1vcmVJbmRlbnRlZCAmJiBsaW5lICE9PSAnJ1xuICAgICAgICA/ICdcXG4nIDogJycpXG4gICAgICArIGZvbGRMaW5lKGxpbmUsIHdpZHRoKTtcbiAgICBwcmV2TW9yZUluZGVudGVkID0gbW9yZUluZGVudGVkO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR3JlZWR5IGxpbmUgYnJlYWtpbmcuXG4vLyBQaWNrcyB0aGUgbG9uZ2VzdCBsaW5lIHVuZGVyIHRoZSBsaW1pdCBlYWNoIHRpbWUsXG4vLyBvdGhlcndpc2Ugc2V0dGxlcyBmb3IgdGhlIHNob3J0ZXN0IGxpbmUgb3ZlciB0aGUgbGltaXQuXG4vLyBOQi4gTW9yZS1pbmRlbnRlZCBsaW5lcyAqY2Fubm90KiBiZSBmb2xkZWQsIGFzIHRoYXQgd291bGQgYWRkIGFuIGV4dHJhIFxcbi5cbmZ1bmN0aW9uIGZvbGRMaW5lKGxpbmUsIHdpZHRoKSB7XG4gIGlmIChsaW5lID09PSAnJyB8fCBsaW5lWzBdID09PSAnICcpIHJldHVybiBsaW5lO1xuXG4gIC8vIFNpbmNlIGEgbW9yZS1pbmRlbnRlZCBsaW5lIGFkZHMgYSBcXG4sIGJyZWFrcyBjYW4ndCBiZSBmb2xsb3dlZCBieSBhIHNwYWNlLlxuICB2YXIgYnJlYWtSZSA9IC8gW14gXS9nOyAvLyBub3RlOiB0aGUgbWF0Y2ggaW5kZXggd2lsbCBhbHdheXMgYmUgPD0gbGVuZ3RoLTIuXG4gIHZhciBtYXRjaDtcbiAgLy8gc3RhcnQgaXMgYW4gaW5jbHVzaXZlIGluZGV4LiBlbmQsIGN1cnIsIGFuZCBuZXh0IGFyZSBleGNsdXNpdmUuXG4gIHZhciBzdGFydCA9IDAsIGVuZCwgY3VyciA9IDAsIG5leHQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgLy8gSW52YXJpYW50czogMCA8PSBzdGFydCA8PSBsZW5ndGgtMS5cbiAgLy8gICAwIDw9IGN1cnIgPD0gbmV4dCA8PSBtYXgoMCwgbGVuZ3RoLTIpLiBjdXJyIC0gc3RhcnQgPD0gd2lkdGguXG4gIC8vIEluc2lkZSB0aGUgbG9vcDpcbiAgLy8gICBBIG1hdGNoIGltcGxpZXMgbGVuZ3RoID49IDIsIHNvIGN1cnIgYW5kIG5leHQgYXJlIDw9IGxlbmd0aC0yLlxuICB3aGlsZSAoKG1hdGNoID0gYnJlYWtSZS5leGVjKGxpbmUpKSkge1xuICAgIG5leHQgPSBtYXRjaC5pbmRleDtcbiAgICAvLyBtYWludGFpbiBpbnZhcmlhbnQ6IGN1cnIgLSBzdGFydCA8PSB3aWR0aFxuICAgIGlmIChuZXh0IC0gc3RhcnQgPiB3aWR0aCkge1xuICAgICAgZW5kID0gKGN1cnIgPiBzdGFydCkgPyBjdXJyIDogbmV4dDsgLy8gZGVyaXZlIGVuZCA8PSBsZW5ndGgtMlxuICAgICAgcmVzdWx0ICs9ICdcXG4nICsgbGluZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIC8vIHNraXAgdGhlIHNwYWNlIHRoYXQgd2FzIG91dHB1dCBhcyBcXG5cbiAgICAgIHN0YXJ0ID0gZW5kICsgMTsgICAgICAgICAgICAgICAgICAgIC8vIGRlcml2ZSBzdGFydCA8PSBsZW5ndGgtMVxuICAgIH1cbiAgICBjdXJyID0gbmV4dDtcbiAgfVxuXG4gIC8vIEJ5IHRoZSBpbnZhcmlhbnRzLCBzdGFydCA8PSBsZW5ndGgtMSwgc28gdGhlcmUgaXMgc29tZXRoaW5nIGxlZnQgb3Zlci5cbiAgLy8gSXQgaXMgZWl0aGVyIHRoZSB3aG9sZSBzdHJpbmcgb3IgYSBwYXJ0IHN0YXJ0aW5nIGZyb20gbm9uLXdoaXRlc3BhY2UuXG4gIHJlc3VsdCArPSAnXFxuJztcbiAgLy8gSW5zZXJ0IGEgYnJlYWsgaWYgdGhlIHJlbWFpbmRlciBpcyB0b28gbG9uZyBhbmQgdGhlcmUgaXMgYSBicmVhayBhdmFpbGFibGUuXG4gIGlmIChsaW5lLmxlbmd0aCAtIHN0YXJ0ID4gd2lkdGggJiYgY3VyciA+IHN0YXJ0KSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQsIGN1cnIpICsgJ1xcbicgKyBsaW5lLnNsaWNlKGN1cnIgKyAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnNsaWNlKDEpOyAvLyBkcm9wIGV4dHJhIFxcbiBqb2luZXJcbn1cblxuLy8gRXNjYXBlcyBhIGRvdWJsZS1xdW90ZWQgc3RyaW5nLlxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBjaGFyID0gMDtcbiAgdmFyIGVzY2FwZVNlcTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgIGNoYXIgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGkpO1xuICAgIGVzY2FwZVNlcSA9IEVTQ0FQRV9TRVFVRU5DRVNbY2hhcl07XG5cbiAgICBpZiAoIWVzY2FwZVNlcSAmJiBpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ1tpXTtcbiAgICAgIGlmIChjaGFyID49IDB4MTAwMDApIHJlc3VsdCArPSBzdHJpbmdbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gZXNjYXBlU2VxIHx8IGVuY29kZUhleChjaGFyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgdmFsdWU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdmFsdWUgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICB2YWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBTdHJpbmcoaW5kZXgpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cywgcHV0IG51bGwgaW5zdGVhZCBvZiBpbnZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCB2YWx1ZSwgZmFsc2UsIGZhbHNlKSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgbnVsbCwgZmFsc2UsIGZhbHNlKSkpIHtcblxuICAgICAgaWYgKF9yZXN1bHQgIT09ICcnKSBfcmVzdWx0ICs9ICcsJyArICghc3RhdGUuY29uZGVuc2VGbG93ID8gJyAnIDogJycpO1xuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAnWycgKyBfcmVzdWx0ICsgJ10nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIHZhbHVlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHZhbHVlID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgU3RyaW5nKGluZGV4KSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMsIHB1dCBudWxsIGluc3RlYWQgb2YgaW52YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIHZhbHVlLCB0cnVlLCB0cnVlLCBmYWxzZSwgdHJ1ZSkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBudWxsLCB0cnVlLCB0cnVlLCBmYWxzZSwgdHJ1ZSkpKSB7XG5cbiAgICAgIGlmICghY29tcGFjdCB8fCBfcmVzdWx0ICE9PSAnJykge1xuICAgICAgICBfcmVzdWx0ICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBfcmVzdWx0ICs9ICctJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0gJztcbiAgICAgIH1cblxuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICdbXSc7IC8vIEVtcHR5IHNlcXVlbmNlIGlmIG5vIHZhbGlkIHZhbHVlcy5cbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuXG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuICAgIGlmIChfcmVzdWx0ICE9PSAnJykgcGFpckJ1ZmZlciArPSAnLCAnO1xuXG4gICAgaWYgKHN0YXRlLmNvbmRlbnNlRmxvdykgcGFpckJ1ZmZlciArPSAnXCInO1xuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgb2JqZWN0VmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgb2JqZWN0S2V5LCBvYmplY3RWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RLZXksIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpIHBhaXJCdWZmZXIgKz0gJz8gJztcblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcCArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnXCInIDogJycpICsgJzonICsgKHN0YXRlLmNvbmRlbnNlRmxvdyA/ICcnIDogJyAnKTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0VmFsdWUsIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ3snICsgX3Jlc3VsdCArICd9Jztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBleHBsaWNpdFBhaXIsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIC8vIEFsbG93IHNvcnRpbmcga2V5cyBzbyB0aGF0IHRoZSBvdXRwdXQgZmlsZSBpcyBkZXRlcm1pbmlzdGljXG4gIGlmIChzdGF0ZS5zb3J0S2V5cyA9PT0gdHJ1ZSkge1xuICAgIC8vIERlZmF1bHQgc29ydGluZ1xuICAgIG9iamVjdEtleUxpc3Quc29ydCgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0ZS5zb3J0S2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEN1c3RvbSBzb3J0IGZ1bmN0aW9uXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KHN0YXRlLnNvcnRLZXlzKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zb3J0S2V5cykge1xuICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZ1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ3NvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoIWNvbXBhY3QgfHwgX3Jlc3VsdCAhPT0gJycpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIG9iamVjdFZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIG9iamVjdEtleSwgb2JqZWN0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdEtleSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5LlxuICAgIH1cblxuICAgIGV4cGxpY2l0UGFpciA9IChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8XG4gICAgICAgICAgICAgICAgICAgKHN0YXRlLmR1bXAgJiYgc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KTtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0VmFsdWUsIHRydWUsIGV4cGxpY2l0UGFpcikpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzogJztcbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICd7fSc7IC8vIEVtcHR5IG1hcHBpbmcgaWYgbm8gdmFsaWQgcGFpcnMuXG59XG5cbmZ1bmN0aW9uIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZXhwbGljaXQpIHtcbiAgdmFyIF9yZXN1bHQsIHR5cGVMaXN0LCBpbmRleCwgbGVuZ3RoLCB0eXBlLCBzdHlsZTtcblxuICB0eXBlTGlzdCA9IGV4cGxpY2l0ID8gc3RhdGUuZXhwbGljaXRUeXBlcyA6IHN0YXRlLmltcGxpY2l0VHlwZXM7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHR5cGVMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gdHlwZUxpc3RbaW5kZXhdO1xuXG4gICAgaWYgKCh0eXBlLmluc3RhbmNlT2YgIHx8IHR5cGUucHJlZGljYXRlKSAmJlxuICAgICAgICAoIXR5cGUuaW5zdGFuY2VPZiB8fCAoKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSAmJiAob2JqZWN0IGluc3RhbmNlb2YgdHlwZS5pbnN0YW5jZU9mKSkpICYmXG4gICAgICAgICghdHlwZS5wcmVkaWNhdGUgIHx8IHR5cGUucHJlZGljYXRlKG9iamVjdCkpKSB7XG5cbiAgICAgIGlmIChleHBsaWNpdCkge1xuICAgICAgICBpZiAodHlwZS5tdWx0aSAmJiB0eXBlLnJlcHJlc2VudE5hbWUpIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnJlcHJlc2VudE5hbWUob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gJz8nO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZS5yZXByZXNlbnQpIHtcbiAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHR5cGUucmVwcmVzZW50KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudChvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCchPCcgKyB0eXBlLnRhZyArICc+IHRhZyByZXNvbHZlciBhY2NlcHRzIG5vdCBcIicgKyBzdHlsZSArICdcIiBzdHlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZHVtcCA9IF9yZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gU2VyaWFsaXplcyBgb2JqZWN0YCBhbmQgd3JpdGVzIGl0IHRvIGdsb2JhbCBgcmVzdWx0YC5cbi8vIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBvciBmYWxzZSBvbiBpbnZhbGlkIG9iamVjdC5cbi8vXG5mdW5jdGlvbiB3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3QsIGJsb2NrLCBjb21wYWN0LCBpc2tleSwgaXNibG9ja3NlcSkge1xuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5kdW1wID0gb2JqZWN0O1xuXG4gIGlmICghZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBmYWxzZSkpIHtcbiAgICBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIHRydWUpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBfdG9TdHJpbmcuY2FsbChzdGF0ZS5kdW1wKTtcbiAgdmFyIGluYmxvY2sgPSBibG9jaztcbiAgdmFyIHRhZ1N0cjtcblxuICBpZiAoYmxvY2spIHtcbiAgICBibG9jayA9IChzdGF0ZS5mbG93TGV2ZWwgPCAwIHx8IHN0YXRlLmZsb3dMZXZlbCA+IGxldmVsKTtcbiAgfVxuXG4gIHZhciBvYmplY3RPckFycmF5ID0gdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGR1cGxpY2F0ZUluZGV4LFxuICAgICAgZHVwbGljYXRlO1xuXG4gIGlmIChvYmplY3RPckFycmF5KSB7XG4gICAgZHVwbGljYXRlSW5kZXggPSBzdGF0ZS5kdXBsaWNhdGVzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBkdXBsaWNhdGUgPSBkdXBsaWNhdGVJbmRleCAhPT0gLTE7XG4gIH1cblxuICBpZiAoKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JykgfHwgZHVwbGljYXRlIHx8IChzdGF0ZS5pbmRlbnQgIT09IDIgJiYgbGV2ZWwgPiAwKSkge1xuICAgIGNvbXBhY3QgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChkdXBsaWNhdGUgJiYgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgc3RhdGUuZHVtcCA9ICcqcmVmXycgKyBkdXBsaWNhdGVJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheSAmJiBkdXBsaWNhdGUgJiYgIXN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgICAgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKE9iamVjdC5rZXlzKHN0YXRlLmR1bXApLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgaWYgKGJsb2NrICYmIChzdGF0ZS5kdW1wLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgaWYgKHN0YXRlLm5vQXJyYXlJbmRlbnQgJiYgIWlzYmxvY2tzZXEgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICAgICAgd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCAtIDEsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICAgIHdyaXRlU2NhbGFyKHN0YXRlLCBzdGF0ZS5kdW1wLCBsZXZlbCwgaXNrZXksIGluYmxvY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVW5kZWZpbmVkXScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCd1bmFjY2VwdGFibGUga2luZCBvZiBhbiBvYmplY3QgdG8gZHVtcCAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgLy8gTmVlZCB0byBlbmNvZGUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IHRob3NlIGFsbG93ZWQgYnkgdGhlIHNwZWM6XG4gICAgICAvL1xuICAgICAgLy8gWzM1XSBucy1kZWMtZGlnaXQgICAgOjo9ICBbI3gzMC0jeDM5XSAvKiAwLTkgKi9cbiAgICAgIC8vIFszNl0gbnMtaGV4LWRpZ2l0ICAgIDo6PSAgbnMtZGVjLWRpZ2l0XG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IFsjeDQxLSN4NDZdIC8qIEEtRiAqLyB8IFsjeDYxLSN4NjZdIC8qIGEtZiAqL1xuICAgICAgLy8gWzM3XSBucy1hc2NpaS1sZXR0ZXIgOjo9ICBbI3g0MS0jeDVBXSAvKiBBLVogKi8gfCBbI3g2MS0jeDdBXSAvKiBhLXogKi9cbiAgICAgIC8vIFszOF0gbnMtd29yZC1jaGFyICAgIDo6PSAgbnMtZGVjLWRpZ2l0IHwgbnMtYXNjaWktbGV0dGVyIHwg4oCcLeKAnVxuICAgICAgLy8gWzM5XSBucy11cmktY2hhciAgICAgOjo9ICDigJwl4oCdIG5zLWhleC1kaWdpdCBucy1oZXgtZGlnaXQgfCBucy13b3JkLWNoYXIgfCDigJwj4oCdXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IOKAnDvigJ0gfCDigJwv4oCdIHwg4oCcP+KAnSB8IOKAnDrigJ0gfCDigJxA4oCdIHwg4oCcJuKAnSB8IOKAnD3igJ0gfCDigJwr4oCdIHwg4oCcJOKAnSB8IOKAnCzigJ1cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHwg4oCcX+KAnSB8IOKAnC7igJ0gfCDigJwh4oCdIHwg4oCcfuKAnSB8IOKAnCrigJ0gfCDigJwn4oCdIHwg4oCcKOKAnSB8IOKAnCnigJ0gfCDigJxb4oCdIHwg4oCcXeKAnVxuICAgICAgLy9cbiAgICAgIC8vIEFsc28gbmVlZCB0byBlbmNvZGUgJyEnIGJlY2F1c2UgaXQgaGFzIHNwZWNpYWwgbWVhbmluZyAoZW5kIG9mIHRhZyBwcmVmaXgpLlxuICAgICAgLy9cbiAgICAgIHRhZ1N0ciA9IGVuY29kZVVSSShcbiAgICAgICAgc3RhdGUudGFnWzBdID09PSAnIScgPyBzdGF0ZS50YWcuc2xpY2UoMSkgOiBzdGF0ZS50YWdcbiAgICAgICkucmVwbGFjZSgvIS9nLCAnJTIxJyk7XG5cbiAgICAgIGlmIChzdGF0ZS50YWdbMF0gPT09ICchJykge1xuICAgICAgICB0YWdTdHIgPSAnIScgKyB0YWdTdHI7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1N0ci5zbGljZSgwLCAxOCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjonKSB7XG4gICAgICAgIHRhZ1N0ciA9ICchIScgKyB0YWdTdHIuc2xpY2UoMTgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnU3RyID0gJyE8JyArIHRhZ1N0ciArICc+JztcbiAgICAgIH1cblxuICAgICAgc3RhdGUuZHVtcCA9IHRhZ1N0ciArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZVJlZmVyZW5jZXMob2JqZWN0LCBzdGF0ZSkge1xuICB2YXIgb2JqZWN0cyA9IFtdLFxuICAgICAgZHVwbGljYXRlc0luZGV4ZXMgPSBbXSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkdXBsaWNhdGVzSW5kZXhlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgc3RhdGUuZHVwbGljYXRlcy5wdXNoKG9iamVjdHNbZHVwbGljYXRlc0luZGV4ZXNbaW5kZXhdXSk7XG4gIH1cbiAgc3RhdGUudXNlZER1cGxpY2F0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcykge1xuICB2YXIgb2JqZWN0S2V5TGlzdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgZHVwbGljYXRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtpbmRleF0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtvYmplY3RLZXlMaXN0W2luZGV4XV0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkdW1wJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKG9wdGlvbnMpO1xuXG4gIGlmICghc3RhdGUubm9SZWZzKSBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKGlucHV0LCBzdGF0ZSk7XG5cbiAgdmFyIHZhbHVlID0gaW5wdXQ7XG5cbiAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKHsgJyc6IHZhbHVlIH0sICcnLCB2YWx1ZSk7XG4gIH1cblxuICBpZiAod3JpdGVOb2RlKHN0YXRlLCAwLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpIHJldHVybiBzdGF0ZS5kdW1wICsgJ1xcbic7XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgZHVtcF8xID0gZHVtcCQxO1xuXG52YXIgZHVtcGVyID0ge1xuXHRkdW1wOiBkdW1wXzFcbn07XG5cbmZ1bmN0aW9uIHJlbmFtZWQoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHlhbWwuJyArIGZyb20gKyAnIGlzIHJlbW92ZWQgaW4ganMteWFtbCA0LiAnICtcbiAgICAgICdVc2UgeWFtbC4nICsgdG8gKyAnIGluc3RlYWQsIHdoaWNoIGlzIG5vdyBzYWZlIGJ5IGRlZmF1bHQuJyk7XG4gIH07XG59XG5cblxudmFyIFR5cGUgICAgICAgICAgICAgICAgPSB0eXBlO1xudmFyIFNjaGVtYSAgICAgICAgICAgICAgPSBzY2hlbWE7XG52YXIgRkFJTFNBRkVfU0NIRU1BICAgICA9IGZhaWxzYWZlO1xudmFyIEpTT05fU0NIRU1BICAgICAgICAgPSBqc29uO1xudmFyIENPUkVfU0NIRU1BICAgICAgICAgPSBjb3JlO1xudmFyIERFRkFVTFRfU0NIRU1BICAgICAgPSBfZGVmYXVsdDtcbnZhciBsb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG52YXIgbG9hZEFsbCAgICAgICAgICAgICA9IGxvYWRlci5sb2FkQWxsO1xudmFyIGR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbnZhciBZQU1MRXhjZXB0aW9uICAgICAgID0gZXhjZXB0aW9uO1xuXG4vLyBSZS1leHBvcnQgYWxsIHR5cGVzIGluIGNhc2UgdXNlciB3YW50cyB0byBjcmVhdGUgY3VzdG9tIHNjaGVtYVxudmFyIHR5cGVzID0ge1xuICBiaW5hcnk6ICAgIGJpbmFyeSxcbiAgZmxvYXQ6ICAgICBmbG9hdCxcbiAgbWFwOiAgICAgICBtYXAsXG4gIG51bGw6ICAgICAgX251bGwsXG4gIHBhaXJzOiAgICAgcGFpcnMsXG4gIHNldDogICAgICAgc2V0LFxuICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgYm9vbDogICAgICBib29sLFxuICBpbnQ6ICAgICAgIGludCxcbiAgbWVyZ2U6ICAgICBtZXJnZSxcbiAgb21hcDogICAgICBvbWFwLFxuICBzZXE6ICAgICAgIHNlcSxcbiAgc3RyOiAgICAgICBzdHJcbn07XG5cbi8vIFJlbW92ZWQgZnVuY3Rpb25zIGZyb20gSlMtWUFNTCAzLjAueFxudmFyIHNhZmVMb2FkICAgICAgICAgICAgPSByZW5hbWVkKCdzYWZlTG9hZCcsICdsb2FkJyk7XG52YXIgc2FmZUxvYWRBbGwgICAgICAgICA9IHJlbmFtZWQoJ3NhZmVMb2FkQWxsJywgJ2xvYWRBbGwnKTtcbnZhciBzYWZlRHVtcCAgICAgICAgICAgID0gcmVuYW1lZCgnc2FmZUR1bXAnLCAnZHVtcCcpO1xuXG52YXIganNZYW1sID0ge1xuXHRUeXBlOiBUeXBlLFxuXHRTY2hlbWE6IFNjaGVtYSxcblx0RkFJTFNBRkVfU0NIRU1BOiBGQUlMU0FGRV9TQ0hFTUEsXG5cdEpTT05fU0NIRU1BOiBKU09OX1NDSEVNQSxcblx0Q09SRV9TQ0hFTUE6IENPUkVfU0NIRU1BLFxuXHRERUZBVUxUX1NDSEVNQTogREVGQVVMVF9TQ0hFTUEsXG5cdGxvYWQ6IGxvYWQsXG5cdGxvYWRBbGw6IGxvYWRBbGwsXG5cdGR1bXA6IGR1bXAsXG5cdFlBTUxFeGNlcHRpb246IFlBTUxFeGNlcHRpb24sXG5cdHR5cGVzOiB0eXBlcyxcblx0c2FmZUxvYWQ6IHNhZmVMb2FkLFxuXHRzYWZlTG9hZEFsbDogc2FmZUxvYWRBbGwsXG5cdHNhZmVEdW1wOiBzYWZlRHVtcFxufTtcblxuZXhwb3J0IHsgQ09SRV9TQ0hFTUEsIERFRkFVTFRfU0NIRU1BLCBGQUlMU0FGRV9TQ0hFTUEsIEpTT05fU0NIRU1BLCBTY2hlbWEsIFR5cGUsIFlBTUxFeGNlcHRpb24sIGpzWWFtbCBhcyBkZWZhdWx0LCBkdW1wLCBsb2FkLCBsb2FkQWxsLCBzYWZlRHVtcCwgc2FmZUxvYWQsIHNhZmVMb2FkQWxsLCB0eXBlcyB9O1xuIl0sIm5hbWVzIjpbImlzTm90aGluZyIsInN1YmplY3QiLCJpc09iamVjdCIsInRvQXJyYXkiLCJzZXF1ZW5jZSIsIkFycmF5IiwiaXNBcnJheSIsImV4dGVuZCIsInRhcmdldCIsInNvdXJjZSIsImluZGV4IiwibGVuZ3RoIiwia2V5Iiwic291cmNlS2V5cyIsIk9iamVjdCIsImtleXMiLCJyZXBlYXQiLCJzdHJpbmciLCJjb3VudCIsInJlc3VsdCIsImN5Y2xlIiwiaXNOZWdhdGl2ZVplcm8iLCJudW1iZXIiLCJOdW1iZXIiLCJORUdBVElWRV9JTkZJTklUWSIsImlzTm90aGluZ18xIiwiaXNPYmplY3RfMSIsInRvQXJyYXlfMSIsInJlcGVhdF8xIiwiaXNOZWdhdGl2ZVplcm9fMSIsImV4dGVuZF8xIiwiY29tbW9uIiwiZm9ybWF0RXJyb3IiLCJleGNlcHRpb24iLCJjb21wYWN0Iiwid2hlcmUiLCJtZXNzYWdlIiwicmVhc29uIiwibWFyayIsIm5hbWUiLCJsaW5lIiwiY29sdW1uIiwic25pcHBldCIsIllBTUxFeGNlcHRpb24kMSIsIkVycm9yIiwiY2FsbCIsImNhcHR1cmVTdGFja1RyYWNlIiwiY29uc3RydWN0b3IiLCJzdGFjayIsInByb3RvdHlwZSIsImNyZWF0ZSIsInRvU3RyaW5nIiwiZ2V0TGluZSIsImJ1ZmZlciIsImxpbmVTdGFydCIsImxpbmVFbmQiLCJwb3NpdGlvbiIsIm1heExpbmVMZW5ndGgiLCJoZWFkIiwidGFpbCIsIm1heEhhbGZMZW5ndGgiLCJNYXRoIiwiZmxvb3IiLCJzdHIiLCJzbGljZSIsInJlcGxhY2UiLCJwb3MiLCJwYWRTdGFydCIsIm1heCIsIm1ha2VTbmlwcGV0Iiwib3B0aW9ucyIsIm1heExlbmd0aCIsImluZGVudCIsImxpbmVzQmVmb3JlIiwibGluZXNBZnRlciIsInJlIiwibGluZVN0YXJ0cyIsImxpbmVFbmRzIiwibWF0Y2giLCJmb3VuZExpbmVObyIsImV4ZWMiLCJwdXNoIiwiaSIsImxpbmVOb0xlbmd0aCIsIm1pbiIsIlRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUyIsIllBTUxfTk9ERV9LSU5EUyIsImNvbXBpbGVTdHlsZUFsaWFzZXMiLCJtYXAiLCJmb3JFYWNoIiwic3R5bGUiLCJhbGlhcyIsIlN0cmluZyIsIlR5cGUkMSIsInRhZyIsImluZGV4T2YiLCJraW5kIiwicmVzb2x2ZSIsImNvbnN0cnVjdCIsImRhdGEiLCJpbnN0YW5jZU9mIiwicHJlZGljYXRlIiwicmVwcmVzZW50IiwicmVwcmVzZW50TmFtZSIsImRlZmF1bHRTdHlsZSIsIm11bHRpIiwic3R5bGVBbGlhc2VzIiwidHlwZSIsImNvbXBpbGVMaXN0Iiwic2NoZW1hIiwiY3VycmVudFR5cGUiLCJuZXdJbmRleCIsInByZXZpb3VzVHlwZSIsInByZXZpb3VzSW5kZXgiLCJjb21waWxlTWFwIiwic2NhbGFyIiwibWFwcGluZyIsImZhbGxiYWNrIiwiY29sbGVjdFR5cGUiLCJhcmd1bWVudHMiLCJTY2hlbWEkMSIsImRlZmluaXRpb24iLCJpbXBsaWNpdCIsImV4cGxpY2l0IiwiY29uY2F0IiwidHlwZSQxIiwibG9hZEtpbmQiLCJjb21waWxlZEltcGxpY2l0IiwiY29tcGlsZWRFeHBsaWNpdCIsImNvbXBpbGVkVHlwZU1hcCIsInNlcSIsImZhaWxzYWZlIiwicmVzb2x2ZVlhbWxOdWxsIiwiY29uc3RydWN0WWFtbE51bGwiLCJpc051bGwiLCJvYmplY3QiLCJfbnVsbCIsImNhbm9uaWNhbCIsImxvd2VyY2FzZSIsInVwcGVyY2FzZSIsImNhbWVsY2FzZSIsImVtcHR5IiwicmVzb2x2ZVlhbWxCb29sZWFuIiwiY29uc3RydWN0WWFtbEJvb2xlYW4iLCJpc0Jvb2xlYW4iLCJib29sIiwiaXNIZXhDb2RlIiwiYyIsImlzT2N0Q29kZSIsImlzRGVjQ29kZSIsInJlc29sdmVZYW1sSW50ZWdlciIsImhhc0RpZ2l0cyIsImNoIiwiY2hhckNvZGVBdCIsImNvbnN0cnVjdFlhbWxJbnRlZ2VyIiwidmFsdWUiLCJzaWduIiwicGFyc2VJbnQiLCJpc0ludGVnZXIiLCJpbnQiLCJiaW5hcnkiLCJvYmoiLCJvY3RhbCIsImRlY2ltYWwiLCJoZXhhZGVjaW1hbCIsInRvVXBwZXJDYXNlIiwiWUFNTF9GTE9BVF9QQVRURVJOIiwiUmVnRXhwIiwicmVzb2x2ZVlhbWxGbG9hdCIsInRlc3QiLCJjb25zdHJ1Y3RZYW1sRmxvYXQiLCJ0b0xvd2VyQ2FzZSIsIlBPU0lUSVZFX0lORklOSVRZIiwiTmFOIiwicGFyc2VGbG9hdCIsIlNDSUVOVElGSUNfV0lUSE9VVF9ET1QiLCJyZXByZXNlbnRZYW1sRmxvYXQiLCJyZXMiLCJpc05hTiIsImlzRmxvYXQiLCJmbG9hdCIsImpzb24iLCJjb3JlIiwiWUFNTF9EQVRFX1JFR0VYUCIsIllBTUxfVElNRVNUQU1QX1JFR0VYUCIsInJlc29sdmVZYW1sVGltZXN0YW1wIiwiY29uc3RydWN0WWFtbFRpbWVzdGFtcCIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJmcmFjdGlvbiIsImRlbHRhIiwidHpfaG91ciIsInR6X21pbnV0ZSIsImRhdGUiLCJEYXRlIiwiVVRDIiwic2V0VGltZSIsImdldFRpbWUiLCJyZXByZXNlbnRZYW1sVGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJ0aW1lc3RhbXAiLCJyZXNvbHZlWWFtbE1lcmdlIiwibWVyZ2UiLCJCQVNFNjRfTUFQIiwicmVzb2x2ZVlhbWxCaW5hcnkiLCJjb2RlIiwiaWR4IiwiYml0bGVuIiwiY2hhckF0IiwiY29uc3RydWN0WWFtbEJpbmFyeSIsInRhaWxiaXRzIiwiaW5wdXQiLCJiaXRzIiwiVWludDhBcnJheSIsInJlcHJlc2VudFlhbWxCaW5hcnkiLCJpc0JpbmFyeSIsIl9oYXNPd25Qcm9wZXJ0eSQzIiwiaGFzT3duUHJvcGVydHkiLCJfdG9TdHJpbmckMiIsInJlc29sdmVZYW1sT21hcCIsIm9iamVjdEtleXMiLCJwYWlyIiwicGFpcktleSIsInBhaXJIYXNLZXkiLCJjb25zdHJ1Y3RZYW1sT21hcCIsIm9tYXAiLCJfdG9TdHJpbmckMSIsInJlc29sdmVZYW1sUGFpcnMiLCJjb25zdHJ1Y3RZYW1sUGFpcnMiLCJwYWlycyIsIl9oYXNPd25Qcm9wZXJ0eSQyIiwicmVzb2x2ZVlhbWxTZXQiLCJjb25zdHJ1Y3RZYW1sU2V0Iiwic2V0IiwiX2RlZmF1bHQiLCJfaGFzT3duUHJvcGVydHkkMSIsIkNPTlRFWFRfRkxPV19JTiIsIkNPTlRFWFRfRkxPV19PVVQiLCJDT05URVhUX0JMT0NLX0lOIiwiQ09OVEVYVF9CTE9DS19PVVQiLCJDSE9NUElOR19DTElQIiwiQ0hPTVBJTkdfU1RSSVAiLCJDSE9NUElOR19LRUVQIiwiUEFUVEVSTl9OT05fUFJJTlRBQkxFIiwiUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MiLCJQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUyIsIlBBVFRFUk5fVEFHX0hBTkRMRSIsIlBBVFRFUk5fVEFHX1VSSSIsIl9jbGFzcyIsImlzX0VPTCIsImlzX1dISVRFX1NQQUNFIiwiaXNfV1NfT1JfRU9MIiwiaXNfRkxPV19JTkRJQ0FUT1IiLCJmcm9tSGV4Q29kZSIsImxjIiwiZXNjYXBlZEhleExlbiIsImZyb21EZWNpbWFsQ29kZSIsInNpbXBsZUVzY2FwZVNlcXVlbmNlIiwiY2hhckZyb21Db2RlcG9pbnQiLCJmcm9tQ2hhckNvZGUiLCJzZXRQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwic2ltcGxlRXNjYXBlQ2hlY2siLCJzaW1wbGVFc2NhcGVNYXAiLCJTdGF0ZSQxIiwiZmlsZW5hbWUiLCJvbldhcm5pbmciLCJsZWdhY3kiLCJsaXN0ZW5lciIsImltcGxpY2l0VHlwZXMiLCJ0eXBlTWFwIiwibGluZUluZGVudCIsImZpcnN0VGFiSW5MaW5lIiwiZG9jdW1lbnRzIiwiZ2VuZXJhdGVFcnJvciIsInN0YXRlIiwidGhyb3dFcnJvciIsInRocm93V2FybmluZyIsImRpcmVjdGl2ZUhhbmRsZXJzIiwiWUFNTCIsImhhbmRsZVlhbWxEaXJlY3RpdmUiLCJhcmdzIiwibWFqb3IiLCJtaW5vciIsInZlcnNpb24iLCJjaGVja0xpbmVCcmVha3MiLCJUQUciLCJoYW5kbGVUYWdEaXJlY3RpdmUiLCJoYW5kbGUiLCJwcmVmaXgiLCJ0YWdNYXAiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlcnIiLCJjYXB0dXJlU2VnbWVudCIsInN0YXJ0IiwiZW5kIiwiY2hlY2tKc29uIiwiX3Bvc2l0aW9uIiwiX2xlbmd0aCIsIl9jaGFyYWN0ZXIiLCJfcmVzdWx0IiwibWVyZ2VNYXBwaW5ncyIsImRlc3RpbmF0aW9uIiwib3ZlcnJpZGFibGVLZXlzIiwicXVhbnRpdHkiLCJzdG9yZU1hcHBpbmdQYWlyIiwia2V5VGFnIiwia2V5Tm9kZSIsInZhbHVlTm9kZSIsInN0YXJ0TGluZSIsInN0YXJ0TGluZVN0YXJ0Iiwic3RhcnRQb3MiLCJyZWFkTGluZUJyZWFrIiwic2tpcFNlcGFyYXRpb25TcGFjZSIsImFsbG93Q29tbWVudHMiLCJjaGVja0luZGVudCIsImxpbmVCcmVha3MiLCJ0ZXN0RG9jdW1lbnRTZXBhcmF0b3IiLCJ3cml0ZUZvbGRlZExpbmVzIiwicmVhZFBsYWluU2NhbGFyIiwibm9kZUluZGVudCIsIndpdGhpbkZsb3dDb2xsZWN0aW9uIiwicHJlY2VkaW5nIiwiZm9sbG93aW5nIiwiY2FwdHVyZVN0YXJ0IiwiY2FwdHVyZUVuZCIsImhhc1BlbmRpbmdDb250ZW50IiwiX2xpbmUiLCJfbGluZVN0YXJ0IiwiX2xpbmVJbmRlbnQiLCJfa2luZCIsInJlYWRTaW5nbGVRdW90ZWRTY2FsYXIiLCJyZWFkRG91YmxlUXVvdGVkU2NhbGFyIiwiaGV4TGVuZ3RoIiwiaGV4UmVzdWx0IiwidG1wIiwicmVhZEZsb3dDb2xsZWN0aW9uIiwicmVhZE5leHQiLCJfcG9zIiwiX3RhZyIsIl9hbmNob3IiLCJhbmNob3IiLCJ0ZXJtaW5hdG9yIiwiaXNQYWlyIiwiaXNFeHBsaWNpdFBhaXIiLCJpc01hcHBpbmciLCJhbmNob3JNYXAiLCJjb21wb3NlTm9kZSIsInJlYWRCbG9ja1NjYWxhciIsImZvbGRpbmciLCJjaG9tcGluZyIsImRpZFJlYWRDb250ZW50IiwiZGV0ZWN0ZWRJbmRlbnQiLCJ0ZXh0SW5kZW50IiwiZW1wdHlMaW5lcyIsImF0TW9yZUluZGVudGVkIiwicmVhZEJsb2NrU2VxdWVuY2UiLCJkZXRlY3RlZCIsInJlYWRCbG9ja01hcHBpbmciLCJmbG93SW5kZW50IiwiYWxsb3dDb21wYWN0IiwiX2tleUxpbmUiLCJfa2V5TGluZVN0YXJ0IiwiX2tleVBvcyIsImF0RXhwbGljaXRLZXkiLCJyZWFkVGFnUHJvcGVydHkiLCJpc1ZlcmJhdGltIiwiaXNOYW1lZCIsInRhZ0hhbmRsZSIsInRhZ05hbWUiLCJyZWFkQW5jaG9yUHJvcGVydHkiLCJyZWFkQWxpYXMiLCJwYXJlbnRJbmRlbnQiLCJub2RlQ29udGV4dCIsImFsbG93VG9TZWVrIiwiYWxsb3dCbG9ja1N0eWxlcyIsImFsbG93QmxvY2tTY2FsYXJzIiwiYWxsb3dCbG9ja0NvbGxlY3Rpb25zIiwiaW5kZW50U3RhdHVzIiwiYXROZXdMaW5lIiwiaGFzQ29udGVudCIsInR5cGVJbmRleCIsInR5cGVRdWFudGl0eSIsInR5cGVMaXN0IiwiYmxvY2tJbmRlbnQiLCJyZWFkRG9jdW1lbnQiLCJkb2N1bWVudFN0YXJ0IiwiZGlyZWN0aXZlTmFtZSIsImRpcmVjdGl2ZUFyZ3MiLCJoYXNEaXJlY3RpdmVzIiwibG9hZERvY3VtZW50cyIsIm51bGxwb3MiLCJsb2FkQWxsJDEiLCJpdGVyYXRvciIsImxvYWQkMSIsInVuZGVmaW5lZCIsImxvYWRBbGxfMSIsImxvYWRfMSIsImxvYWRlciIsImxvYWRBbGwiLCJsb2FkIiwiX3RvU3RyaW5nIiwiX2hhc093blByb3BlcnR5IiwiQ0hBUl9CT00iLCJDSEFSX1RBQiIsIkNIQVJfTElORV9GRUVEIiwiQ0hBUl9DQVJSSUFHRV9SRVRVUk4iLCJDSEFSX1NQQUNFIiwiQ0hBUl9FWENMQU1BVElPTiIsIkNIQVJfRE9VQkxFX1FVT1RFIiwiQ0hBUl9TSEFSUCIsIkNIQVJfUEVSQ0VOVCIsIkNIQVJfQU1QRVJTQU5EIiwiQ0hBUl9TSU5HTEVfUVVPVEUiLCJDSEFSX0FTVEVSSVNLIiwiQ0hBUl9DT01NQSIsIkNIQVJfTUlOVVMiLCJDSEFSX0NPTE9OIiwiQ0hBUl9FUVVBTFMiLCJDSEFSX0dSRUFURVJfVEhBTiIsIkNIQVJfUVVFU1RJT04iLCJDSEFSX0NPTU1FUkNJQUxfQVQiLCJDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQiLCJDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9HUkFWRV9BQ0NFTlQiLCJDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCIsIkNIQVJfVkVSVElDQUxfTElORSIsIkNIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCIsIkVTQ0FQRV9TRVFVRU5DRVMiLCJERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWCIsIkRFUFJFQ0FURURfQkFTRTYwX1NZTlRBWCIsImNvbXBpbGVTdHlsZU1hcCIsImVuY29kZUhleCIsImNoYXJhY3RlciIsIlFVT1RJTkdfVFlQRV9TSU5HTEUiLCJRVU9USU5HX1RZUEVfRE9VQkxFIiwiU3RhdGUiLCJub0FycmF5SW5kZW50Iiwic2tpcEludmFsaWQiLCJmbG93TGV2ZWwiLCJzdHlsZU1hcCIsInNvcnRLZXlzIiwibGluZVdpZHRoIiwibm9SZWZzIiwibm9Db21wYXRNb2RlIiwiY29uZGVuc2VGbG93IiwicXVvdGluZ1R5cGUiLCJmb3JjZVF1b3RlcyIsInJlcGxhY2VyIiwiZXhwbGljaXRUeXBlcyIsImR1cGxpY2F0ZXMiLCJ1c2VkRHVwbGljYXRlcyIsImluZGVudFN0cmluZyIsInNwYWNlcyIsImluZCIsIm5leHQiLCJnZW5lcmF0ZU5leHRMaW5lIiwibGV2ZWwiLCJ0ZXN0SW1wbGljaXRSZXNvbHZpbmciLCJpc1doaXRlc3BhY2UiLCJpc1ByaW50YWJsZSIsImlzTnNDaGFyT3JXaGl0ZXNwYWNlIiwiaXNQbGFpblNhZmUiLCJwcmV2IiwiaW5ibG9jayIsImNJc05zQ2hhck9yV2hpdGVzcGFjZSIsImNJc05zQ2hhciIsImlzUGxhaW5TYWZlRmlyc3QiLCJpc1BsYWluU2FmZUxhc3QiLCJjb2RlUG9pbnRBdCIsImZpcnN0IiwibmVlZEluZGVudEluZGljYXRvciIsImxlYWRpbmdTcGFjZVJlIiwiU1RZTEVfUExBSU4iLCJTVFlMRV9TSU5HTEUiLCJTVFlMRV9MSVRFUkFMIiwiU1RZTEVfRk9MREVEIiwiU1RZTEVfRE9VQkxFIiwiY2hvb3NlU2NhbGFyU3R5bGUiLCJzaW5nbGVMaW5lT25seSIsImluZGVudFBlckxldmVsIiwidGVzdEFtYmlndW91c1R5cGUiLCJjaGFyIiwicHJldkNoYXIiLCJoYXNMaW5lQnJlYWsiLCJoYXNGb2xkYWJsZUxpbmUiLCJzaG91bGRUcmFja1dpZHRoIiwicHJldmlvdXNMaW5lQnJlYWsiLCJwbGFpbiIsIndyaXRlU2NhbGFyIiwiaXNrZXkiLCJkdW1wIiwidGVzdEFtYmlndWl0eSIsImJsb2NrSGVhZGVyIiwiZHJvcEVuZGluZ05ld2xpbmUiLCJmb2xkU3RyaW5nIiwiZXNjYXBlU3RyaW5nIiwiaW5kZW50SW5kaWNhdG9yIiwiY2xpcCIsImtlZXAiLCJjaG9tcCIsIndpZHRoIiwibGluZVJlIiwibmV4dExGIiwibGFzdEluZGV4IiwiZm9sZExpbmUiLCJwcmV2TW9yZUluZGVudGVkIiwibW9yZUluZGVudGVkIiwiYnJlYWtSZSIsImN1cnIiLCJlc2NhcGVTZXEiLCJ3cml0ZUZsb3dTZXF1ZW5jZSIsIndyaXRlTm9kZSIsIndyaXRlQmxvY2tTZXF1ZW5jZSIsIndyaXRlRmxvd01hcHBpbmciLCJvYmplY3RLZXlMaXN0Iiwib2JqZWN0S2V5Iiwib2JqZWN0VmFsdWUiLCJwYWlyQnVmZmVyIiwid3JpdGVCbG9ja01hcHBpbmciLCJleHBsaWNpdFBhaXIiLCJzb3J0IiwiZGV0ZWN0VHlwZSIsImJsb2NrIiwiaXNibG9ja3NlcSIsInRhZ1N0ciIsIm9iamVjdE9yQXJyYXkiLCJkdXBsaWNhdGVJbmRleCIsImR1cGxpY2F0ZSIsImVuY29kZVVSSSIsImdldER1cGxpY2F0ZVJlZmVyZW5jZXMiLCJvYmplY3RzIiwiZHVwbGljYXRlc0luZGV4ZXMiLCJpbnNwZWN0Tm9kZSIsImR1bXAkMSIsImR1bXBfMSIsImR1bXBlciIsInJlbmFtZWQiLCJmcm9tIiwidG8iLCJUeXBlIiwiU2NoZW1hIiwiRkFJTFNBRkVfU0NIRU1BIiwiSlNPTl9TQ0hFTUEiLCJDT1JFX1NDSEVNQSIsIkRFRkFVTFRfU0NIRU1BIiwiWUFNTEV4Y2VwdGlvbiIsInR5cGVzIiwibnVsbCIsInNhZmVMb2FkIiwic2FmZUxvYWRBbGwiLCJzYWZlRHVtcCIsImpzWWFtbCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/js-yaml/dist/js-yaml.mjs\n");

/***/ })

};
;